"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chess.js";
exports.ids = ["vendor-chunks/chess.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chess.js/dist/esm/chess.js":
/*!*************************************************!*\
  !*** ./node_modules/chess.js/dist/esm/chess.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BISHOP: () => (/* binding */ BISHOP),\n/* harmony export */   BLACK: () => (/* binding */ BLACK),\n/* harmony export */   Chess: () => (/* binding */ Chess),\n/* harmony export */   DEFAULT_POSITION: () => (/* binding */ DEFAULT_POSITION),\n/* harmony export */   KING: () => (/* binding */ KING),\n/* harmony export */   KNIGHT: () => (/* binding */ KNIGHT),\n/* harmony export */   PAWN: () => (/* binding */ PAWN),\n/* harmony export */   QUEEN: () => (/* binding */ QUEEN),\n/* harmony export */   ROOK: () => (/* binding */ ROOK),\n/* harmony export */   SQUARES: () => (/* binding */ SQUARES),\n/* harmony export */   WHITE: () => (/* binding */ WHITE),\n/* harmony export */   validateFen: () => (/* binding */ validateFen)\n/* harmony export */ });\n/**\n * @license\n * Copyright (c) 2023, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nconst WHITE = 'w';\nconst BLACK = 'b';\nconst PAWN = 'p';\nconst KNIGHT = 'n';\nconst BISHOP = 'b';\nconst ROOK = 'r';\nconst QUEEN = 'q';\nconst KING = 'k';\nconst DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nconst SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [KNIGHT, BISHOP, ROOK, QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [KING]: BITS.KSIDE_CASTLE,\n    [QUEEN]: BITS.QSIDE_CASTLE\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === WHITE ? BLACK : WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    return { ok: true };\n}\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    constructor(fen = DEFAULT_POSITION) {\n        this.load(fen);\n    }\n    clear(keepHeaders = false) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = keepHeaders ? this._header : {};\n        this._updateSetup(this.fen());\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            delete this._header[key];\n        }\n    }\n    load(fen, keepHeaders = false) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        const { ok, error } = validateFen(fen);\n        if (!ok) {\n            throw new Error(error);\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear(keepHeaders);\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? WHITE : BLACK;\n                this.put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(this.fen());\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: PAWN,\n                        captured: PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            delete this._header['SetUp'];\n            delete this._header['FEN'];\n        }\n    }\n    reset() {\n        this.load(DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]] || false;\n    }\n    put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === KING) {\n            this._kings[color] = sq;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = (this._board[Ox88.e1]?.type === KING && this._board[Ox88.e1]?.color === WHITE);\n        const blackKingInPlace = (this._board[Ox88.e8]?.type === KING && this._board[Ox88.e8]?.color === BLACK);\n        if (!whiteKingInPlace || this._board[Ox88.a1]?.type !== ROOK || this._board[Ox88.a1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace || this._board[Ox88.h1]?.type !== ROOK || this._board[Ox88.h1]?.color !== WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || this._board[Ox88.a8]?.type !== ROOK || this._board[Ox88.a8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace || this._board[Ox88.h8]?.type !== ROOK || this._board[Ox88.h8]?.color !== BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square) {\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE)\n                            return true;\n                    }\n                    else {\n                        if (piece.color === BLACK)\n                            return true;\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k')\n                    return true;\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked)\n                    return true;\n            }\n        }\n        return false;\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        const moves = [];\n        const positions = {};\n        let repetition = false;\n        while (true) {\n            const move = this._undoMove();\n            if (!move)\n                break;\n            moves.push(move);\n        }\n        while (true) {\n            /*\n             * remove the last two fields in the FEN string, they're not needed when\n             * checking for draw by rep\n             */\n            const fen = this.fen().split(' ').slice(0, 4).join(' ');\n            // has the position occurred three or move times\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1;\n            if (positions[fen] >= 3) {\n                repetition = true;\n            }\n            const move = moves.pop();\n            if (!move) {\n                break;\n            }\n            else {\n                this._makeMove(move);\n            }\n        }\n        return repetition;\n    }\n    isDraw() {\n        return (this._halfMoves >= 100 || // 50 moves per side = 100 half moves\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => this._makePretty(move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === KNIGHT || type === KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = this._makePretty(moveObj);\n        this._makeMove(moveObj);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        return move ? this._makePretty(move) : null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             */\n            result.push('[' + i + ' \"' + this._header[i] + '\"]' + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result?\n        if (typeof this._header.Result !== 'undefined') {\n            moves.push(this._header.Result);\n        }\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, true);\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // second argument to load: don't clear the headers\n                this.load(headers['FEN'], true);\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result && Object.keys(this._header).length && !this._header['Result']) {\n            this.header('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n        //     piece         from              to       promotion\n        );\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove === strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    // pretty = external move object\n    _makePretty(uglyMove) {\n        const { color, piece, from, to, flags, captured, promotion } = uglyMove;\n        let prettyFlags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                prettyFlags += FLAGS[flag];\n            }\n        }\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        const move = {\n            color,\n            piece,\n            from: fromAlgebraic,\n            to: toAlgebraic,\n            san: this._moveToSan(uglyMove, this._moves({ legal: true })),\n            flags: prettyFlags,\n            lan: fromAlgebraic + toAlgebraic,\n            before: this.fen(),\n            after: '',\n        };\n        // generate the FEN for the 'after' key\n        this._makeMove(uglyMove);\n        move.after = this.fen();\n        this._undoMove();\n        if (captured) {\n            move.captured = captured;\n        }\n        if (promotion) {\n            move.promotion = promotion;\n            move.lan += promotion;\n        }\n        return move;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(this._makePretty(move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    deleteComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    deleteComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [KING, QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return (rights[KING] === undefined || rights[KING] === result[KING]) && (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN]);\n    }\n    getCastlingRights(color) {\n        return {\n            [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n            [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\n//# sourceMappingURL=chess.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQkFBK0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0NBQWtDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixjQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFNBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvY2hlc3MuanMvZGlzdC9lc20vY2hlc3MuanM/YzNiMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjMsIEplZmYgSGx5d2EgKGpobHl3YUBnbWFpbC5jb20pXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKlxuICogMS4gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqIDIuIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAqICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb25cbiAqICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFXG4gKiBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SXG4gKiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRlxuICogU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTXG4gKiBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTlxuICogQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSlcbiAqIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFXG4gKiBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuZXhwb3J0IGNvbnN0IFdISVRFID0gJ3cnO1xuZXhwb3J0IGNvbnN0IEJMQUNLID0gJ2InO1xuZXhwb3J0IGNvbnN0IFBBV04gPSAncCc7XG5leHBvcnQgY29uc3QgS05JR0hUID0gJ24nO1xuZXhwb3J0IGNvbnN0IEJJU0hPUCA9ICdiJztcbmV4cG9ydCBjb25zdCBST09LID0gJ3InO1xuZXhwb3J0IGNvbnN0IFFVRUVOID0gJ3EnO1xuZXhwb3J0IGNvbnN0IEtJTkcgPSAnayc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QT1NJVElPTiA9ICdybmJxa2Juci9wcHBwcHBwcC84LzgvOC84L1BQUFBQUFBQL1JOQlFLQk5SIHcgS1FrcSAtIDAgMSc7XG5jb25zdCBFTVBUWSA9IC0xO1xuY29uc3QgRkxBR1MgPSB7XG4gICAgTk9STUFMOiAnbicsXG4gICAgQ0FQVFVSRTogJ2MnLFxuICAgIEJJR19QQVdOOiAnYicsXG4gICAgRVBfQ0FQVFVSRTogJ2UnLFxuICAgIFBST01PVElPTjogJ3AnLFxuICAgIEtTSURFX0NBU1RMRTogJ2snLFxuICAgIFFTSURFX0NBU1RMRTogJ3EnLFxufTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZXhwb3J0IGNvbnN0IFNRVUFSRVMgPSBbXG4gICAgJ2E4JywgJ2I4JywgJ2M4JywgJ2Q4JywgJ2U4JywgJ2Y4JywgJ2c4JywgJ2g4JyxcbiAgICAnYTcnLCAnYjcnLCAnYzcnLCAnZDcnLCAnZTcnLCAnZjcnLCAnZzcnLCAnaDcnLFxuICAgICdhNicsICdiNicsICdjNicsICdkNicsICdlNicsICdmNicsICdnNicsICdoNicsXG4gICAgJ2E1JywgJ2I1JywgJ2M1JywgJ2Q1JywgJ2U1JywgJ2Y1JywgJ2c1JywgJ2g1JyxcbiAgICAnYTQnLCAnYjQnLCAnYzQnLCAnZDQnLCAnZTQnLCAnZjQnLCAnZzQnLCAnaDQnLFxuICAgICdhMycsICdiMycsICdjMycsICdkMycsICdlMycsICdmMycsICdnMycsICdoMycsXG4gICAgJ2EyJywgJ2IyJywgJ2MyJywgJ2QyJywgJ2UyJywgJ2YyJywgJ2cyJywgJ2gyJyxcbiAgICAnYTEnLCAnYjEnLCAnYzEnLCAnZDEnLCAnZTEnLCAnZjEnLCAnZzEnLCAnaDEnXG5dO1xuY29uc3QgQklUUyA9IHtcbiAgICBOT1JNQUw6IDEsXG4gICAgQ0FQVFVSRTogMixcbiAgICBCSUdfUEFXTjogNCxcbiAgICBFUF9DQVBUVVJFOiA4LFxuICAgIFBST01PVElPTjogMTYsXG4gICAgS1NJREVfQ0FTVExFOiAzMixcbiAgICBRU0lERV9DQVNUTEU6IDY0LFxufTtcbi8qXG4gKiBOT1RFUyBBQk9VVCAweDg4IE1PVkUgR0VORVJBVElPTiBBTEdPUklUSE1cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2pobHl3YS9jaGVzcy5qcy9pc3N1ZXMvMjMwXG4gKlxuICogQSBsb3Qgb2YgcGVvcGxlIGFyZSBjb25mdXNlZCB3aGVuIHRoZXkgZmlyc3Qgc2VlIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvblxuICogb2YgY2hlc3MuanMuIEl0IHVzZXMgdGhlIDB4ODggTW92ZSBHZW5lcmF0aW9uIEFsZ29yaXRobSB3aGljaCBpbnRlcm5hbGx5XG4gKiBzdG9yZXMgdGhlIGJvYXJkIGFzIGFuIDh4MTYgYXJyYXkuIFRoaXMgaXMgcHVyZWx5IGZvciBlZmZpY2llbmN5IGJ1dCBoYXMgYVxuICogY291cGxlIG9mIGludGVyZXN0aW5nIGJlbmVmaXRzOlxuICpcbiAqIDEuIDB4ODggb2ZmZXJzIGEgdmVyeSBpbmV4cGVuc2l2ZSBcIm9mZiB0aGUgYm9hcmRcIiBjaGVjay4gQml0d2lzZSBBTkQgKCYpIGFueVxuICogICAgc3F1YXJlIHdpdGggMHg4OCwgaWYgdGhlIHJlc3VsdCBpcyBub24temVybyB0aGVuIHRoZSBzcXVhcmUgaXMgb2ZmIHRoZVxuICogICAgYm9hcmQuIEZvciBleGFtcGxlLCBhc3N1bWluZyBhIGtuaWdodCBzcXVhcmUgQTggKDAgaW4gMHg4OCBub3RhdGlvbiksXG4gKiAgICB0aGVyZSBhcmUgOCBwb3NzaWJsZSBkaXJlY3Rpb25zIGluIHdoaWNoIHRoZSBrbmlnaHQgY2FuIG1vdmUuIFRoZXNlXG4gKiAgICBkaXJlY3Rpb25zIGFyZSByZWxhdGl2ZSB0byB0aGUgOHgxNiBib2FyZCBhbmQgYXJlIHN0b3JlZCBpbiB0aGVcbiAqICAgIFBJRUNFX09GRlNFVFMgbWFwLiBPbmUgcG9zc2libGUgbW92ZSBpcyBBOCAtIDE4ICh1cCBvbmUgc3F1YXJlLCBhbmQgdHdvXG4gKiAgICBzcXVhcmVzIHRvIHRoZSBsZWZ0IC0gd2hpY2ggaXMgb2ZmIHRoZSBib2FyZCkuIDAgLSAxOCA9IC0xOCAmIDB4ODggPSAweDg4XG4gKiAgICAoYmVjYXVzZSBvZiB0d28tY29tcGxlbWVudCByZXByZXNlbnRhdGlvbiBvZiAtMTgpLiBUaGUgbm9uLXplcm8gcmVzdWx0XG4gKiAgICBtZWFucyB0aGUgc3F1YXJlIGlzIG9mZiB0aGUgYm9hcmQgYW5kIHRoZSBtb3ZlIGlzIGlsbGVnYWwuIFRha2UgdGhlXG4gKiAgICBvcHBvc2l0ZSBtb3ZlIChmcm9tIEE4IHRvIEM3KSwgMCArIDE4ID0gMTggJiAweDg4ID0gMC4gQSByZXN1bHQgb2YgemVyb1xuICogICAgbWVhbnMgdGhlIHNxdWFyZSBpcyBvbiB0aGUgYm9hcmQuXG4gKlxuICogMi4gVGhlIHJlbGF0aXZlIGRpc3RhbmNlIChvciBkaWZmZXJlbmNlKSBiZXR3ZWVuIHR3byBzcXVhcmVzIG9uIGEgOHgxNiBib2FyZFxuICogICAgaXMgdW5pcXVlIGFuZCBjYW4gYmUgdXNlZCB0byBpbmV4cGVuc2l2ZWx5IGRldGVybWluZSBpZiBhIHBpZWNlIG9uIGFcbiAqICAgIHNxdWFyZSBjYW4gYXR0YWNrIGFueSBvdGhlciBhcmJpdHJhcnkgc3F1YXJlLiBGb3IgZXhhbXBsZSwgbGV0J3Mgc2VlIGlmIGFcbiAqICAgIHBhd24gb24gRTcgY2FuIGF0dGFjayBFMi4gVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBFNyAoMjApIC0gRTIgKDEwMCkgaXNcbiAqICAgIC04MC4gV2UgYWRkIDExOSB0byBtYWtlIHRoZSBBVFRBQ0tTIGFycmF5IGluZGV4IG5vbi1uZWdhdGl2ZSAoYmVjYXVzZSB0aGVcbiAqICAgIHdvcnN0IGNhc2UgZGlmZmVyZW5jZSBpcyBBOCAtIEgxID0gLTExOSkuIFRoZSBBVFRBQ0tTIGFycmF5IGNvbnRhaW5zIGFcbiAqICAgIGJpdG1hc2sgb2YgcGllY2VzIHRoYXQgY2FuIGF0dGFjayBmcm9tIHRoYXQgZGlzdGFuY2UgYW5kIGRpcmVjdGlvbi5cbiAqICAgIEFUVEFDS1NbLTgwICsgMTE5PTM5XSBnaXZlcyB1cyAyNCBvciAwYjExMDAwIGluIGJpbmFyeS4gTG9vayBhdCB0aGVcbiAqICAgIFBJRUNFX01BU0tTIG1hcCB0byBkZXRlcm1pbmUgdGhlIG1hc2sgZm9yIGEgZ2l2ZW4gcGllY2UgdHlwZS4gSW4gb3VyIHBhd25cbiAqICAgIGV4YW1wbGUsIHdlIHdvdWxkIGNoZWNrIHRvIHNlZSBpZiAyNCAmIDB4MSBpcyBub24temVybywgd2hpY2ggaXQgaXNcbiAqICAgIG5vdC4gU28sIG5hdHVyYWxseSwgYSBwYXduIG9uIEU3IGNhbid0IGF0dGFjayBhIHBpZWNlIG9uIEUyLiBIb3dldmVyLCBhXG4gKiAgICByb29rIGNhbiBzaW5jZSAyNCAmIDB4OCBpcyBub24temVyby4gVGhlIG9ubHkgdGhpbmcgbGVmdCB0byBjaGVjayBpcyB0aGF0XG4gKiAgICB0aGVyZSBhcmUgbm8gYmxvY2tpbmcgcGllY2VzIGJldHdlZW4gRTcgYW5kIEUyLiBUaGF0J3Mgd2hlcmUgdGhlIFJBWVNcbiAqICAgIGFycmF5IGNvbWVzIGluLiBJdCBwcm92aWRlcyBhbiBvZmZzZXQgKGluIHRoaXMgY2FzZSAxNikgdG8gYWRkIHRvIEU3ICgyMClcbiAqICAgIHRvIGNoZWNrIGZvciBibG9ja2luZyBwaWVjZXMuIEU3ICgyMCkgKyAxNiA9IEU2ICgzNikgKyAxNiA9IEU1ICg1MikgZXRjLlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuY29uc3QgT3g4OCA9IHtcbiAgICBhODogMCwgYjg6IDEsIGM4OiAyLCBkODogMywgZTg6IDQsIGY4OiA1LCBnODogNiwgaDg6IDcsXG4gICAgYTc6IDE2LCBiNzogMTcsIGM3OiAxOCwgZDc6IDE5LCBlNzogMjAsIGY3OiAyMSwgZzc6IDIyLCBoNzogMjMsXG4gICAgYTY6IDMyLCBiNjogMzMsIGM2OiAzNCwgZDY6IDM1LCBlNjogMzYsIGY2OiAzNywgZzY6IDM4LCBoNjogMzksXG4gICAgYTU6IDQ4LCBiNTogNDksIGM1OiA1MCwgZDU6IDUxLCBlNTogNTIsIGY1OiA1MywgZzU6IDU0LCBoNTogNTUsXG4gICAgYTQ6IDY0LCBiNDogNjUsIGM0OiA2NiwgZDQ6IDY3LCBlNDogNjgsIGY0OiA2OSwgZzQ6IDcwLCBoNDogNzEsXG4gICAgYTM6IDgwLCBiMzogODEsIGMzOiA4MiwgZDM6IDgzLCBlMzogODQsIGYzOiA4NSwgZzM6IDg2LCBoMzogODcsXG4gICAgYTI6IDk2LCBiMjogOTcsIGMyOiA5OCwgZDI6IDk5LCBlMjogMTAwLCBmMjogMTAxLCBnMjogMTAyLCBoMjogMTAzLFxuICAgIGExOiAxMTIsIGIxOiAxMTMsIGMxOiAxMTQsIGQxOiAxMTUsIGUxOiAxMTYsIGYxOiAxMTcsIGcxOiAxMTgsIGgxOiAxMTlcbn07XG5jb25zdCBQQVdOX09GRlNFVFMgPSB7XG4gICAgYjogWzE2LCAzMiwgMTcsIDE1XSxcbiAgICB3OiBbLTE2LCAtMzIsIC0xNywgLTE1XSxcbn07XG5jb25zdCBQSUVDRV9PRkZTRVRTID0ge1xuICAgIG46IFstMTgsIC0zMywgLTMxLCAtMTQsIDE4LCAzMywgMzEsIDE0XSxcbiAgICBiOiBbLTE3LCAtMTUsIDE3LCAxNV0sXG4gICAgcjogWy0xNiwgMSwgMTYsIC0xXSxcbiAgICBxOiBbLTE3LCAtMTYsIC0xNSwgMSwgMTcsIDE2LCAxNSwgLTFdLFxuICAgIGs6IFstMTcsIC0xNiwgLTE1LCAxLCAxNywgMTYsIDE1LCAtMV0sXG59O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBBVFRBQ0tTID0gW1xuICAgIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMCwgMjAsIDAsXG4gICAgMCwgMjAsIDAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAwLCAyMCwgMCwgMCxcbiAgICAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMjAsIDAsIDAsIDI0LCAwLCAwLCAyMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAyMCwgMiwgMjQsIDIsIDIwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIsIDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgNTYsIDAsIDU2LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDIsIDUzLCA1NiwgNTMsIDIsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMjAsIDIsIDI0LCAyLCAyMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMjQsIDAsIDAsIDIwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDIwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMjAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMjAsIDAsIDAsIDAsIDAsIDI0LCAwLCAwLCAwLCAwLCAyMCwgMCwgMCwgMCxcbiAgICAwLCAyMCwgMCwgMCwgMCwgMCwgMCwgMjQsIDAsIDAsIDAsIDAsIDAsIDIwLCAwLCAwLFxuICAgIDIwLCAwLCAwLCAwLCAwLCAwLCAwLCAyNCwgMCwgMCwgMCwgMCwgMCwgMCwgMjBcbl07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFJBWVMgPSBbXG4gICAgMTcsIDAsIDAsIDAsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAwLCAwLCAwLCAxNSwgMCxcbiAgICAwLCAxNywgMCwgMCwgMCwgMCwgMCwgMTYsIDAsIDAsIDAsIDAsIDAsIDE1LCAwLCAwLFxuICAgIDAsIDAsIDE3LCAwLCAwLCAwLCAwLCAxNiwgMCwgMCwgMCwgMCwgMTUsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMTcsIDAsIDAsIDAsIDE2LCAwLCAwLCAwLCAxNSwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAwLCAxNywgMCwgMCwgMTYsIDAsIDAsIDE1LCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDE3LCAwLCAxNiwgMCwgMTUsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMTcsIDE2LCAxNSwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgMCxcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAtMTUsIC0xNiwgLTE3LCAwLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIC0xNSwgMCwgLTE2LCAwLCAtMTcsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgLTE1LCAwLCAwLCAtMTYsIDAsIDAsIC0xNywgMCwgMCwgMCwgMCwgMCxcbiAgICAwLCAwLCAwLCAtMTUsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgLTE3LCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIC0xNSwgMCwgMCwgMCwgMCwgLTE2LCAwLCAwLCAwLCAwLCAtMTcsIDAsIDAsIDAsXG4gICAgMCwgLTE1LCAwLCAwLCAwLCAwLCAwLCAtMTYsIDAsIDAsIDAsIDAsIDAsIC0xNywgMCwgMCxcbiAgICAtMTUsIDAsIDAsIDAsIDAsIDAsIDAsIC0xNiwgMCwgMCwgMCwgMCwgMCwgMCwgLTE3XG5dO1xuY29uc3QgUElFQ0VfTUFTS1MgPSB7IHA6IDB4MSwgbjogMHgyLCBiOiAweDQsIHI6IDB4OCwgcTogMHgxMCwgazogMHgyMCB9O1xuY29uc3QgU1lNQk9MUyA9ICdwbmJycWtQTkJSUUsnO1xuY29uc3QgUFJPTU9USU9OUyA9IFtLTklHSFQsIEJJU0hPUCwgUk9PSywgUVVFRU5dO1xuY29uc3QgUkFOS18xID0gNztcbmNvbnN0IFJBTktfMiA9IDY7XG4vKlxuICogY29uc3QgUkFOS18zID0gNVxuICogY29uc3QgUkFOS180ID0gNFxuICogY29uc3QgUkFOS181ID0gM1xuICogY29uc3QgUkFOS182ID0gMlxuICovXG5jb25zdCBSQU5LXzcgPSAxO1xuY29uc3QgUkFOS184ID0gMDtcbmNvbnN0IFNJREVTID0ge1xuICAgIFtLSU5HXTogQklUUy5LU0lERV9DQVNUTEUsXG4gICAgW1FVRUVOXTogQklUUy5RU0lERV9DQVNUTEVcbn07XG5jb25zdCBST09LUyA9IHtcbiAgICB3OiBbXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4LmExLCBmbGFnOiBCSVRTLlFTSURFX0NBU1RMRSB9LFxuICAgICAgICB7IHNxdWFyZTogT3g4OC5oMSwgZmxhZzogQklUUy5LU0lERV9DQVNUTEUgfSxcbiAgICBdLFxuICAgIGI6IFtcbiAgICAgICAgeyBzcXVhcmU6IE94ODguYTgsIGZsYWc6IEJJVFMuUVNJREVfQ0FTVExFIH0sXG4gICAgICAgIHsgc3F1YXJlOiBPeDg4Lmg4LCBmbGFnOiBCSVRTLktTSURFX0NBU1RMRSB9LFxuICAgIF0sXG59O1xuY29uc3QgU0VDT05EX1JBTksgPSB7IGI6IFJBTktfNywgdzogUkFOS18yIH07XG5jb25zdCBURVJNSU5BVElPTl9NQVJLRVJTID0gWycxLTAnLCAnMC0xJywgJzEvMi0xLzInLCAnKiddO1xuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgcmFuayBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIHJhbmsoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSA+PiA0O1xufVxuLy8gRXh0cmFjdHMgdGhlIHplcm8tYmFzZWQgZmlsZSBvZiBhbiAweDg4IHNxdWFyZS5cbmZ1bmN0aW9uIGZpbGUoc3F1YXJlKSB7XG4gICAgcmV0dXJuIHNxdWFyZSAmIDB4Zjtcbn1cbmZ1bmN0aW9uIGlzRGlnaXQoYykge1xuICAgIHJldHVybiAnMDEyMzQ1Njc4OScuaW5kZXhPZihjKSAhPT0gLTE7XG59XG4vLyBDb252ZXJ0cyBhIDB4ODggc3F1YXJlIHRvIGFsZ2VicmFpYyBub3RhdGlvbi5cbmZ1bmN0aW9uIGFsZ2VicmFpYyhzcXVhcmUpIHtcbiAgICBjb25zdCBmID0gZmlsZShzcXVhcmUpO1xuICAgIGNvbnN0IHIgPSByYW5rKHNxdWFyZSk7XG4gICAgcmV0dXJuICgnYWJjZGVmZ2gnLnN1YnN0cmluZyhmLCBmICsgMSkgK1xuICAgICAgICAnODc2NTQzMjEnLnN1YnN0cmluZyhyLCByICsgMSkpO1xufVxuZnVuY3Rpb24gc3dhcENvbG9yKGNvbG9yKSB7XG4gICAgcmV0dXJuIGNvbG9yID09PSBXSElURSA/IEJMQUNLIDogV0hJVEU7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGZW4oZmVuKSB7XG4gICAgLy8gMXN0IGNyaXRlcmlvbjogNiBzcGFjZS1zZXBlcmF0ZWQgZmllbGRzP1xuICAgIGNvbnN0IHRva2VucyA9IGZlbi5zcGxpdCgvXFxzKy8pO1xuICAgIGlmICh0b2tlbnMubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBtdXN0IGNvbnRhaW4gc2l4IHNwYWNlLWRlbGltaXRlZCBmaWVsZHMnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyAybmQgY3JpdGVyaW9uOiBtb3ZlIG51bWJlciBmaWVsZCBpcyBhIGludGVnZXIgdmFsdWUgPiAwP1xuICAgIGNvbnN0IG1vdmVOdW1iZXIgPSBwYXJzZUludCh0b2tlbnNbNV0sIDEwKTtcbiAgICBpZiAoaXNOYU4obW92ZU51bWJlcikgfHwgbW92ZU51bWJlciA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBtb3ZlIG51bWJlciBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIDNyZCBjcml0ZXJpb246IGhhbGYgbW92ZSBjb3VudGVyIGlzIGFuIGludGVnZXIgPj0gMD9cbiAgICBjb25zdCBoYWxmTW92ZXMgPSBwYXJzZUludCh0b2tlbnNbNF0sIDEwKTtcbiAgICBpZiAoaXNOYU4oaGFsZk1vdmVzKSB8fCBoYWxmTW92ZXMgPCAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogJ0ludmFsaWQgRkVOOiBoYWxmIG1vdmUgY291bnRlciBudW1iZXIgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyJyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gNHRoIGNyaXRlcmlvbjogNHRoIGZpZWxkIGlzIGEgdmFsaWQgZS5wLi1zdHJpbmc/XG4gICAgaWYgKCEvXigtfFthYmNkZWZnaF1bMzZdKSQvLnRlc3QodG9rZW5zWzNdKSkge1xuICAgICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiAnSW52YWxpZCBGRU46IGVuLXBhc3NhbnQgc3F1YXJlIGlzIGludmFsaWQnIH07XG4gICAgfVxuICAgIC8vIDV0aCBjcml0ZXJpb246IDN0aCBmaWVsZCBpcyBhIHZhbGlkIGNhc3RsZS1zdHJpbmc/XG4gICAgaWYgKC9bXmtLcVEtXS8udGVzdCh0b2tlbnNbMl0pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogY2FzdGxpbmcgYXZhaWxhYmlsaXR5IGlzIGludmFsaWQnIH07XG4gICAgfVxuICAgIC8vIDZ0aCBjcml0ZXJpb246IDJuZCBmaWVsZCBpcyBcIndcIiAod2hpdGUpIG9yIFwiYlwiIChibGFjayk/XG4gICAgaWYgKCEvXih3fGIpJC8udGVzdCh0b2tlbnNbMV0pKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogc2lkZS10by1tb3ZlIGlzIGludmFsaWQnIH07XG4gICAgfVxuICAgIC8vIDd0aCBjcml0ZXJpb246IDFzdCBmaWVsZCBjb250YWlucyA4IHJvd3M/XG4gICAgY29uc3Qgcm93cyA9IHRva2Vuc1swXS5zcGxpdCgnLycpO1xuICAgIGlmIChyb3dzLmxlbmd0aCAhPT0gOCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IFwiSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgZG9lcyBub3QgY29udGFpbiA4ICcvJy1kZWxpbWl0ZWQgcm93c1wiLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA4dGggY3JpdGVyaW9uOiBldmVyeSByb3cgaXMgdmFsaWQ/XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciByaWdodCBzdW0gb2YgZmllbGRzIEFORCBub3QgdHdvIG51bWJlcnMgaW4gc3VjY2Vzc2lvblxuICAgICAgICBsZXQgc3VtRmllbGRzID0gMDtcbiAgICAgICAgbGV0IHByZXZpb3VzV2FzTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcm93c1tpXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgaWYgKGlzRGlnaXQocm93c1tpXVtrXSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNXYXNOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiAnSW52YWxpZCBGRU46IHBpZWNlIGRhdGEgaXMgaW52YWxpZCAoY29uc2VjdXRpdmUgbnVtYmVyKScsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bUZpZWxkcyArPSBwYXJzZUludChyb3dzW2ldW2tdLCAxMCk7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNXYXNOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEvXltwcm5icWtQUk5CUUtdJC8udGVzdChyb3dzW2ldW2tdKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkIChpbnZhbGlkIHBpZWNlKScsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1bUZpZWxkcyArPSAxO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzV2FzTnVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1bUZpZWxkcyAhPT0gOCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvazogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEZFTjogcGllY2UgZGF0YSBpcyBpbnZhbGlkICh0b28gbWFueSBzcXVhcmVzIGluIHJhbmspJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCh0b2tlbnNbM11bMV0gPT0gJzMnICYmIHRva2Vuc1sxXSA9PSAndycpIHx8XG4gICAgICAgICh0b2tlbnNbM11bMV0gPT0gJzYnICYmIHRva2Vuc1sxXSA9PSAnYicpKSB7XG4gICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6ICdJbnZhbGlkIEZFTjogaWxsZWdhbCBlbi1wYXNzYW50IHNxdWFyZScgfTtcbiAgICB9XG4gICAgY29uc3Qga2luZ3MgPSBbXG4gICAgICAgIHsgY29sb3I6ICd3aGl0ZScsIHJlZ2V4OiAvSy9nIH0sXG4gICAgICAgIHsgY29sb3I6ICdibGFjaycsIHJlZ2V4OiAvay9nIH0sXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IHsgY29sb3IsIHJlZ2V4IH0gb2Yga2luZ3MpIHtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KHRva2Vuc1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGBJbnZhbGlkIEZFTjogbWlzc2luZyAke2NvbG9yfSBraW5nYCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICgodG9rZW5zWzBdLm1hdGNoKHJlZ2V4KSB8fCBbXSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgb2s6IGZhbHNlLCBlcnJvcjogYEludmFsaWQgRkVOOiB0b28gbWFueSAke2NvbG9yfSBraW5nc2AgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBvazogdHJ1ZSB9O1xufVxuLy8gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IGFtYmlndW91cyBtb3Zlc1xuZnVuY3Rpb24gZ2V0RGlzYW1iaWd1YXRvcihtb3ZlLCBtb3Zlcykge1xuICAgIGNvbnN0IGZyb20gPSBtb3ZlLmZyb207XG4gICAgY29uc3QgdG8gPSBtb3ZlLnRvO1xuICAgIGNvbnN0IHBpZWNlID0gbW92ZS5waWVjZTtcbiAgICBsZXQgYW1iaWd1aXRpZXMgPSAwO1xuICAgIGxldCBzYW1lUmFuayA9IDA7XG4gICAgbGV0IHNhbWVGaWxlID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgYW1iaWdGcm9tID0gbW92ZXNbaV0uZnJvbTtcbiAgICAgICAgY29uc3QgYW1iaWdUbyA9IG1vdmVzW2ldLnRvO1xuICAgICAgICBjb25zdCBhbWJpZ1BpZWNlID0gbW92ZXNbaV0ucGllY2U7XG4gICAgICAgIC8qXG4gICAgICAgICAqIGlmIGEgbW92ZSBvZiB0aGUgc2FtZSBwaWVjZSB0eXBlIGVuZHMgb24gdGhlIHNhbWUgdG8gc3F1YXJlLCB3ZSdsbCBuZWVkXG4gICAgICAgICAqIHRvIGFkZCBhIGRpc2FtYmlndWF0b3IgdG8gdGhlIGFsZ2VicmFpYyBub3RhdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHBpZWNlID09PSBhbWJpZ1BpZWNlICYmIGZyb20gIT09IGFtYmlnRnJvbSAmJiB0byA9PT0gYW1iaWdUbykge1xuICAgICAgICAgICAgYW1iaWd1aXRpZXMrKztcbiAgICAgICAgICAgIGlmIChyYW5rKGZyb20pID09PSByYW5rKGFtYmlnRnJvbSkpIHtcbiAgICAgICAgICAgICAgICBzYW1lUmFuaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpbGUoZnJvbSkgPT09IGZpbGUoYW1iaWdGcm9tKSkge1xuICAgICAgICAgICAgICAgIHNhbWVGaWxlKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFtYmlndWl0aWVzID4gMCkge1xuICAgICAgICBpZiAoc2FtZVJhbmsgPiAwICYmIHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZXJlIGV4aXN0cyBhIHNpbWlsYXIgbW92aW5nIHBpZWNlIG9uIHRoZSBzYW1lIHJhbmsgYW5kIGZpbGUgYXNcbiAgICAgICAgICAgICAqIHRoZSBtb3ZlIGluIHF1ZXN0aW9uLCB1c2UgdGhlIHNxdWFyZSBhcyB0aGUgZGlzYW1iaWd1YXRvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNhbWVGaWxlID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGlmIHRoZSBtb3ZpbmcgcGllY2UgcmVzdHMgb24gdGhlIHNhbWUgZmlsZSwgdXNlIHRoZSByYW5rIHN5bWJvbCBhcyB0aGVcbiAgICAgICAgICAgICAqIGRpc2FtYmlndWF0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmV0dXJuIGFsZ2VicmFpYyhmcm9tKS5jaGFyQXQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlIHVzZSB0aGUgZmlsZSBzeW1ib2xcbiAgICAgICAgICAgIHJldHVybiBhbGdlYnJhaWMoZnJvbSkuY2hhckF0KDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cbmZ1bmN0aW9uIGFkZE1vdmUobW92ZXMsIGNvbG9yLCBmcm9tLCB0bywgcGllY2UsIGNhcHR1cmVkID0gdW5kZWZpbmVkLCBmbGFncyA9IEJJVFMuTk9STUFMKSB7XG4gICAgY29uc3QgciA9IHJhbmsodG8pO1xuICAgIGlmIChwaWVjZSA9PT0gUEFXTiAmJiAociA9PT0gUkFOS18xIHx8IHIgPT09IFJBTktfOCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQUk9NT1RJT05TLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9tb3Rpb24gPSBQUk9NT1RJT05TW2ldO1xuICAgICAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBwaWVjZSxcbiAgICAgICAgICAgICAgICBjYXB0dXJlZCxcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24sXG4gICAgICAgICAgICAgICAgZmxhZ3M6IGZsYWdzIHwgQklUUy5QUk9NT1RJT04sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHBpZWNlLFxuICAgICAgICAgICAgY2FwdHVyZWQsXG4gICAgICAgICAgICBmbGFncyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5mZXJQaWVjZVR5cGUoc2FuKSB7XG4gICAgbGV0IHBpZWNlVHlwZSA9IHNhbi5jaGFyQXQoMCk7XG4gICAgaWYgKHBpZWNlVHlwZSA+PSAnYScgJiYgcGllY2VUeXBlIDw9ICdoJykge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gc2FuLm1hdGNoKC9bYS1oXVxcZC4qW2EtaF1cXGQvKTtcbiAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBBV047XG4gICAgfVxuICAgIHBpZWNlVHlwZSA9IHBpZWNlVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChwaWVjZVR5cGUgPT09ICdvJykge1xuICAgICAgICByZXR1cm4gS0lORztcbiAgICB9XG4gICAgcmV0dXJuIHBpZWNlVHlwZTtcbn1cbi8vIHBhcnNlcyBhbGwgb2YgdGhlIGRlY29yYXRvcnMgb3V0IG9mIGEgU0FOIHN0cmluZ1xuZnVuY3Rpb24gc3RyaXBwZWRTYW4obW92ZSkge1xuICAgIHJldHVybiBtb3ZlLnJlcGxhY2UoLz0vLCAnJykucmVwbGFjZSgvWysjXT9bPyFdKiQvLCAnJyk7XG59XG5leHBvcnQgY2xhc3MgQ2hlc3Mge1xuICAgIF9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgIF90dXJuID0gV0hJVEU7XG4gICAgX2hlYWRlciA9IHt9O1xuICAgIF9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgX2VwU3F1YXJlID0gLTE7XG4gICAgX2hhbGZNb3ZlcyA9IDA7XG4gICAgX21vdmVOdW1iZXIgPSAwO1xuICAgIF9oaXN0b3J5ID0gW107XG4gICAgX2NvbW1lbnRzID0ge307XG4gICAgX2Nhc3RsaW5nID0geyB3OiAwLCBiOiAwIH07XG4gICAgY29uc3RydWN0b3IoZmVuID0gREVGQVVMVF9QT1NJVElPTikge1xuICAgICAgICB0aGlzLmxvYWQoZmVuKTtcbiAgICB9XG4gICAgY2xlYXIoa2VlcEhlYWRlcnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9ib2FyZCA9IG5ldyBBcnJheSgxMjgpO1xuICAgICAgICB0aGlzLl9raW5ncyA9IHsgdzogRU1QVFksIGI6IEVNUFRZIH07XG4gICAgICAgIHRoaXMuX3R1cm4gPSBXSElURTtcbiAgICAgICAgdGhpcy5fY2FzdGxpbmcgPSB7IHc6IDAsIGI6IDAgfTtcbiAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IDE7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5fY29tbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5faGVhZGVyID0ga2VlcEhlYWRlcnMgPyB0aGlzLl9oZWFkZXIgOiB7fTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAodGhpcy5mZW4oKSk7XG4gICAgfVxuICAgIHJlbW92ZUhlYWRlcihrZXkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLl9oZWFkZXIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkKGZlbiwga2VlcEhlYWRlcnMgPSBmYWxzZSkge1xuICAgICAgICBsZXQgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIC8vIGFwcGVuZCBjb21tb25seSBvbWl0dGVkIGZlbiB0b2tlbnNcbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggPj0gMiAmJiB0b2tlbnMubGVuZ3RoIDwgNikge1xuICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudHMgPSBbJy0nLCAnLScsICcwJywgJzEnXTtcbiAgICAgICAgICAgIGZlbiA9IHRva2Vucy5jb25jYXQoYWRqdXN0bWVudHMuc2xpY2UoLSg2IC0gdG9rZW5zLmxlbmd0aCkpKS5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zID0gZmVuLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGNvbnN0IHsgb2ssIGVycm9yIH0gPSB2YWxpZGF0ZUZlbihmZW4pO1xuICAgICAgICBpZiAoIW9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdG9rZW5zWzBdO1xuICAgICAgICBsZXQgc3F1YXJlID0gMDtcbiAgICAgICAgdGhpcy5jbGVhcihrZWVwSGVhZGVycyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9zaXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gcG9zaXRpb24uY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKHBpZWNlID09PSAnLycpIHtcbiAgICAgICAgICAgICAgICBzcXVhcmUgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGlnaXQocGllY2UpKSB7XG4gICAgICAgICAgICAgICAgc3F1YXJlICs9IHBhcnNlSW50KHBpZWNlLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHBpZWNlIDwgJ2EnID8gV0hJVEUgOiBCTEFDSztcbiAgICAgICAgICAgICAgICB0aGlzLnB1dCh7IHR5cGU6IHBpZWNlLnRvTG93ZXJDYXNlKCksIGNvbG9yIH0sIGFsZ2VicmFpYyhzcXVhcmUpKTtcbiAgICAgICAgICAgICAgICBzcXVhcmUrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdG9rZW5zWzFdO1xuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ0snKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53IHw9IEJJVFMuS1NJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbnNbMl0uaW5kZXhPZignUScpID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLncgfD0gQklUUy5RU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2Vuc1syXS5pbmRleE9mKCdrJykgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcuYiB8PSBCSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5zWzJdLmluZGV4T2YoJ3EnKSA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iIHw9IEJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VwU3F1YXJlID0gdG9rZW5zWzNdID09PSAnLScgPyBFTVBUWSA6IE94ODhbdG9rZW5zWzNdXTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gcGFyc2VJbnQodG9rZW5zWzRdLCAxMCk7XG4gICAgICAgIHRoaXMuX21vdmVOdW1iZXIgPSBwYXJzZUludCh0b2tlbnNbNV0sIDEwKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2V0dXAodGhpcy5mZW4oKSk7XG4gICAgfVxuICAgIGZlbigpIHtcbiAgICAgICAgbGV0IGVtcHR5ID0gMDtcbiAgICAgICAgbGV0IGZlbiA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGlmIChlbXB0eSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmVuICs9IGVtcHR5O1xuICAgICAgICAgICAgICAgICAgICBlbXB0eSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IsIHR5cGU6IHBpZWNlIH0gPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgICAgICBmZW4gKz0gY29sb3IgPT09IFdISVRFID8gcGllY2UudG9VcHBlckNhc2UoKSA6IHBpZWNlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbXB0eSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVtcHR5ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmZW4gKz0gZW1wdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpICE9PSBPeDg4LmgxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlbiArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtcHR5ID0gMDtcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhc3RsaW5nID0gJyc7XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ0snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tXSElURV0gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ1EnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ2snO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1tCTEFDS10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgY2FzdGxpbmcgKz0gJ3EnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIHdlIGhhdmUgYW4gZW1wdHkgY2FzdGxpbmcgZmxhZz9cbiAgICAgICAgY2FzdGxpbmcgPSBjYXN0bGluZyB8fCAnLSc7XG4gICAgICAgIGxldCBlcFNxdWFyZSA9ICctJztcbiAgICAgICAgLypcbiAgICAgICAgICogb25seSBwcmludCB0aGUgZXAgc3F1YXJlIGlmIGVuIHBhc3NhbnQgaXMgYSB2YWxpZCBtb3ZlIChwYXduIGlzIHByZXNlbnRcbiAgICAgICAgICogYW5kIGVwIGNhcHR1cmUgaXMgbm90IHBpbm5lZClcbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLl9lcFNxdWFyZSAhPT0gRU1QVFkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ1Bhd25TcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IDE2IDogLTE2KTtcbiAgICAgICAgICAgIGNvbnN0IHNxdWFyZXMgPSBbYmlnUGF3blNxdWFyZSArIDEsIGJpZ1Bhd25TcXVhcmUgLSAxXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3F1YXJlIG9mIHNxdWFyZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgc3F1YXJlIG9mZiB0aGUgYm9hcmQ/XG4gICAgICAgICAgICAgICAgaWYgKHNxdWFyZSAmIDB4ODgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gdGhpcy5fdHVybjtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIHBhd24gdGhhdCBjYW4gY2FwdHVyZSB0aGUgZXBTcXVhcmU/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSBjb2xvciAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwYXduIG1ha2VzIGFuIGVwIGNhcHR1cmUsIGRvZXMgaXQgbGVhdmUgaXQncyBraW5nIGluIGNoZWNrP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IHNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLl9lcFNxdWFyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpZWNlOiBQQVdOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FwdHVyZWQ6IFBBV04sXG4gICAgICAgICAgICAgICAgICAgICAgICBmbGFnczogQklUUy5FUF9DQVBUVVJFLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNMZWdhbCA9ICF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVwIGlzIGxlZ2FsLCBicmVhayBhbmQgc2V0IHRoZSBlcCBzcXVhcmUgaW4gdGhlIEZFTiBvdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVwU3F1YXJlID0gYWxnZWJyYWljKHRoaXMuX2VwU3F1YXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBmZW4sXG4gICAgICAgICAgICB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmcsXG4gICAgICAgICAgICBlcFNxdWFyZSxcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcyxcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIsXG4gICAgICAgIF0uam9pbignICcpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBpbml0aWFsIGJvYXJkIHNldHVwIGlzIGNoYW5nZWQgd2l0aCBwdXQoKSBvciByZW1vdmUoKS5cbiAgICAgKiBtb2RpZmllcyB0aGUgU2V0VXAgYW5kIEZFTiBwcm9wZXJ0aWVzIG9mIHRoZSBoZWFkZXIgb2JqZWN0LiBJZiB0aGUgRkVOXG4gICAgICogaXMgZXF1YWwgdG8gdGhlIGRlZmF1bHQgcG9zaXRpb24sIHRoZSBTZXRVcCBhbmQgRkVOIGFyZSBkZWxldGVkIHRoZSBzZXR1cFxuICAgICAqIGlzIG9ubHkgdXBkYXRlZCBpZiBoaXN0b3J5Lmxlbmd0aCBpcyB6ZXJvLCBpZSBtb3ZlcyBoYXZlbid0IGJlZW4gbWFkZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlU2V0dXAoZmVuKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChmZW4gIT09IERFRkFVTFRfUE9TSVRJT04pIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnU2V0VXAnXSA9ICcxJztcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclsnRkVOJ10gPSBmZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyWydTZXRVcCddO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlclsnRkVOJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubG9hZChERUZBVUxUX1BPU0lUSU9OKTtcbiAgICB9XG4gICAgZ2V0KHNxdWFyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXSB8fCBmYWxzZTtcbiAgICB9XG4gICAgcHV0KHsgdHlwZSwgY29sb3IgfSwgc3F1YXJlKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBwaWVjZVxuICAgICAgICBpZiAoU1lNQk9MUy5pbmRleE9mKHR5cGUudG9Mb3dlckNhc2UoKSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIHZhbGlkIHNxdWFyZVxuICAgICAgICBpZiAoIShzcXVhcmUgaW4gT3g4OCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcSA9IE94ODhbc3F1YXJlXTtcbiAgICAgICAgLy8gZG9uJ3QgbGV0IHRoZSB1c2VyIHBsYWNlIG1vcmUgdGhhbiBvbmUga2luZ1xuICAgICAgICBpZiAodHlwZSA9PSBLSU5HICYmXG4gICAgICAgICAgICAhKHRoaXMuX2tpbmdzW2NvbG9yXSA9PSBFTVBUWSB8fCB0aGlzLl9raW5nc1tjb2xvcl0gPT0gc3EpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm9hcmRbc3FdID0geyB0eXBlOiB0eXBlLCBjb2xvcjogY29sb3IgfTtcbiAgICAgICAgaWYgKHR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW2NvbG9yXSA9IHNxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlbW92ZShzcXVhcmUpIHtcbiAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLmdldChzcXVhcmUpO1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbT3g4OFtzcXVhcmVdXTtcbiAgICAgICAgaWYgKHBpZWNlICYmIHBpZWNlLnR5cGUgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIHRoaXMuX2tpbmdzW3BpZWNlLmNvbG9yXSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNhc3RsaW5nUmlnaHRzKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUVuUGFzc2FudFNxdWFyZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVTZXR1cCh0aGlzLmZlbigpKTtcbiAgICAgICAgcmV0dXJuIHBpZWNlO1xuICAgIH1cbiAgICBfdXBkYXRlQ2FzdGxpbmdSaWdodHMoKSB7XG4gICAgICAgIGNvbnN0IHdoaXRlS2luZ0luUGxhY2UgPSAodGhpcy5fYm9hcmRbT3g4OC5lMV0/LnR5cGUgPT09IEtJTkcgJiYgdGhpcy5fYm9hcmRbT3g4OC5lMV0/LmNvbG9yID09PSBXSElURSk7XG4gICAgICAgIGNvbnN0IGJsYWNrS2luZ0luUGxhY2UgPSAodGhpcy5fYm9hcmRbT3g4OC5lOF0/LnR5cGUgPT09IEtJTkcgJiYgdGhpcy5fYm9hcmRbT3g4OC5lOF0/LmNvbG9yID09PSBCTEFDSyk7XG4gICAgICAgIGlmICghd2hpdGVLaW5nSW5QbGFjZSB8fCB0aGlzLl9ib2FyZFtPeDg4LmExXT8udHlwZSAhPT0gUk9PSyB8fCB0aGlzLl9ib2FyZFtPeDg4LmExXT8uY29sb3IgIT09IFdISVRFKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy53ICY9IH5CSVRTLlFTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdoaXRlS2luZ0luUGxhY2UgfHwgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LnR5cGUgIT09IFJPT0sgfHwgdGhpcy5fYm9hcmRbT3g4OC5oMV0/LmNvbG9yICE9PSBXSElURSkge1xuICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmcudyAmPSB+QklUUy5LU0lERV9DQVNUTEU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFibGFja0tpbmdJblBsYWNlIHx8IHRoaXMuX2JvYXJkW094ODguYThdPy50eXBlICE9PSBST09LIHx8IHRoaXMuX2JvYXJkW094ODguYThdPy5jb2xvciAhPT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nLmIgJj0gfkJJVFMuUVNJREVfQ0FTVExFO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYmxhY2tLaW5nSW5QbGFjZSB8fCB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8udHlwZSAhPT0gUk9PSyB8fCB0aGlzLl9ib2FyZFtPeDg4Lmg4XT8uY29sb3IgIT09IEJMQUNLKSB7XG4gICAgICAgICAgICB0aGlzLl9jYXN0bGluZy5iICY9IH5CSVRTLktTSURFX0NBU1RMRTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfdXBkYXRlRW5QYXNzYW50U3F1YXJlKCkge1xuICAgICAgICBpZiAodGhpcy5fZXBTcXVhcmUgPT09IEVNUFRZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRTcXVhcmUgPSB0aGlzLl9lcFNxdWFyZSArICh0aGlzLl90dXJuID09PSBXSElURSA/IC0xNiA6IDE2KTtcbiAgICAgICAgY29uc3QgY3VycmVudFNxdWFyZSA9IHRoaXMuX2VwU3F1YXJlICsgKHRoaXMuX3R1cm4gPT09IFdISVRFID8gMTYgOiAtMTYpO1xuICAgICAgICBjb25zdCBhdHRhY2tlcnMgPSBbY3VycmVudFNxdWFyZSArIDEsIGN1cnJlbnRTcXVhcmUgLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuX2JvYXJkW3N0YXJ0U3F1YXJlXSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbdGhpcy5fZXBTcXVhcmVdICE9PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjdXJyZW50U3F1YXJlXT8uY29sb3IgIT09IHN3YXBDb2xvcih0aGlzLl90dXJuKSB8fFxuICAgICAgICAgICAgdGhpcy5fYm9hcmRbY3VycmVudFNxdWFyZV0/LnR5cGUgIT09IFBBV04pIHtcbiAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gRU1QVFk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FuQ2FwdHVyZSA9IChzcXVhcmUpID0+ICEoc3F1YXJlICYgMHg4OCkgJiZcbiAgICAgICAgICAgIHRoaXMuX2JvYXJkW3NxdWFyZV0/LmNvbG9yID09PSB0aGlzLl90dXJuICYmXG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtzcXVhcmVdPy50eXBlID09PSBQQVdOO1xuICAgICAgICBpZiAoIWF0dGFja2Vycy5zb21lKGNhbkNhcHR1cmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IEVNUFRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hdHRhY2tlZChjb2xvciwgc3F1YXJlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBPeDg4LmE4OyBpIDw9IE94ODguaDE7IGkrKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGkgKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGVtcHR5IHNxdWFyZSBvciB3cm9uZyBjb2xvclxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2ldID09PSB1bmRlZmluZWQgfHwgdGhpcy5fYm9hcmRbaV0uY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwaWVjZSA9IHRoaXMuX2JvYXJkW2ldO1xuICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IGkgLSBzcXVhcmU7XG4gICAgICAgICAgICAvLyBza2lwIC0gdG8vZnJvbSBzcXVhcmUgYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBkaWZmZXJlbmNlICsgMTE5O1xuICAgICAgICAgICAgaWYgKEFUVEFDS1NbaW5kZXhdICYgUElFQ0VfTUFTS1NbcGllY2UudHlwZV0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGllY2UudHlwZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwaWVjZS5jb2xvciA9PT0gV0hJVEUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGllY2UuY29sb3IgPT09IEJMQUNLKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgcGllY2UgaXMgYSBrbmlnaHQgb3IgYSBraW5nXG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09ICduJyB8fCBwaWVjZS50eXBlID09PSAnaycpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IFJBWVNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGxldCBqID0gaSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBsZXQgYmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChqICE9PSBzcXVhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2JvYXJkW2pdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaiArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghYmxvY2tlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfaXNLaW5nQXR0YWNrZWQoY29sb3IpIHtcbiAgICAgICAgY29uc3Qgc3F1YXJlID0gdGhpcy5fa2luZ3NbY29sb3JdO1xuICAgICAgICByZXR1cm4gc3F1YXJlID09PSAtMSA/IGZhbHNlIDogdGhpcy5fYXR0YWNrZWQoc3dhcENvbG9yKGNvbG9yKSwgc3F1YXJlKTtcbiAgICB9XG4gICAgaXNBdHRhY2tlZChzcXVhcmUsIGF0dGFja2VkQnkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dGFja2VkKGF0dGFja2VkQnksIE94ODhbc3F1YXJlXSk7XG4gICAgfVxuICAgIGlzQ2hlY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0tpbmdBdHRhY2tlZCh0aGlzLl90dXJuKTtcbiAgICB9XG4gICAgaW5DaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpO1xuICAgIH1cbiAgICBpc0NoZWNrbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNDaGVjaygpICYmIHRoaXMuX21vdmVzKCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBpc1N0YWxlbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzQ2hlY2soKSAmJiB0aGlzLl9tb3ZlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgaXNJbnN1ZmZpY2llbnRNYXRlcmlhbCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogay5iLiB2cyBrLmIuIChvZiBvcHBvc2l0ZSBjb2xvcnMpIHdpdGggbWF0ZSBpbiAxOlxuICAgICAgICAgKiA4LzgvOC84LzFiNi84L0IxazUvSzcgYiAtIC0gMCAxXG4gICAgICAgICAqXG4gICAgICAgICAqIGsuYi4gdnMgay5uLiB3aXRoIG1hdGUgaW4gMTpcbiAgICAgICAgICogOC84LzgvOC8xbjYvOC9CNy9LMWs1IGIgLSAtIDIgMVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcGllY2VzID0ge1xuICAgICAgICAgICAgYjogMCxcbiAgICAgICAgICAgIG46IDAsXG4gICAgICAgICAgICByOiAwLFxuICAgICAgICAgICAgcTogMCxcbiAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICBwOiAwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBiaXNob3BzID0gW107XG4gICAgICAgIGxldCBudW1QaWVjZXMgPSAwO1xuICAgICAgICBsZXQgc3F1YXJlQ29sb3IgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIHNxdWFyZUNvbG9yID0gKHNxdWFyZUNvbG9yICsgMSkgJSAyO1xuICAgICAgICAgICAgaWYgKGkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgaSArPSA3O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGllY2UgPSB0aGlzLl9ib2FyZFtpXTtcbiAgICAgICAgICAgIGlmIChwaWVjZSkge1xuICAgICAgICAgICAgICAgIHBpZWNlc1twaWVjZS50eXBlXSA9IHBpZWNlLnR5cGUgaW4gcGllY2VzID8gcGllY2VzW3BpZWNlLnR5cGVdICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBpZWNlLnR5cGUgPT09IEJJU0hPUCkge1xuICAgICAgICAgICAgICAgICAgICBiaXNob3BzLnB1c2goc3F1YXJlQ29sb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBudW1QaWVjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBrIHZzLiBrXG4gICAgICAgIGlmIChudW1QaWVjZXMgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBrIHZzLiBrbiAuLi4uIG9yIC4uLi4gayB2cy4ga2JcbiAgICAgICAgbnVtUGllY2VzID09PSAzICYmXG4gICAgICAgICAgICAocGllY2VzW0JJU0hPUF0gPT09IDEgfHwgcGllY2VzW0tOSUdIVF0gPT09IDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1QaWVjZXMgPT09IHBpZWNlc1tCSVNIT1BdICsgMikge1xuICAgICAgICAgICAgLy8ga2IgdnMuIGtiIHdoZXJlIGFueSBudW1iZXIgb2YgYmlzaG9wcyBhcmUgYWxsIG9uIHRoZSBzYW1lIGNvbG9yXG4gICAgICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJpc2hvcHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN1bSArPSBiaXNob3BzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN1bSA9PT0gMCB8fCBzdW0gPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaXNUaHJlZWZvbGRSZXBldGl0aW9uKCkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcbiAgICAgICAgbGV0IHJlcGV0aXRpb24gPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbW92ZXMucHVzaChtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHJlbW92ZSB0aGUgbGFzdCB0d28gZmllbGRzIGluIHRoZSBGRU4gc3RyaW5nLCB0aGV5J3JlIG5vdCBuZWVkZWQgd2hlblxuICAgICAgICAgICAgICogY2hlY2tpbmcgZm9yIGRyYXcgYnkgcmVwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGZlbiA9IHRoaXMuZmVuKCkuc3BsaXQoJyAnKS5zbGljZSgwLCA0KS5qb2luKCcgJyk7XG4gICAgICAgICAgICAvLyBoYXMgdGhlIHBvc2l0aW9uIG9jY3VycmVkIHRocmVlIG9yIG1vdmUgdGltZXNcbiAgICAgICAgICAgIHBvc2l0aW9uc1tmZW5dID0gZmVuIGluIHBvc2l0aW9ucyA/IHBvc2l0aW9uc1tmZW5dICsgMSA6IDE7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25zW2Zlbl0gPj0gMykge1xuICAgICAgICAgICAgICAgIHJlcGV0aXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW92ZSA9IG1vdmVzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVwZXRpdGlvbjtcbiAgICB9XG4gICAgaXNEcmF3KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hhbGZNb3ZlcyA+PSAxMDAgfHwgLy8gNTAgbW92ZXMgcGVyIHNpZGUgPSAxMDAgaGFsZiBtb3Zlc1xuICAgICAgICAgICAgdGhpcy5pc1N0YWxlbWF0ZSgpIHx8XG4gICAgICAgICAgICB0aGlzLmlzSW5zdWZmaWNpZW50TWF0ZXJpYWwoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc1RocmVlZm9sZFJlcGV0aXRpb24oKSk7XG4gICAgfVxuICAgIGlzR2FtZU92ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ2hlY2ttYXRlKCkgfHwgdGhpcy5pc1N0YWxlbWF0ZSgpIHx8IHRoaXMuaXNEcmF3KCk7XG4gICAgfVxuICAgIG1vdmVzKHsgdmVyYm9zZSA9IGZhbHNlLCBzcXVhcmUgPSB1bmRlZmluZWQsIHBpZWNlID0gdW5kZWZpbmVkLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSB0aGlzLl9tb3Zlcyh7IHNxdWFyZSwgcGllY2UgfSk7XG4gICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXMubWFwKChtb3ZlKSA9PiB0aGlzLl9tYWtlUHJldHR5KG1vdmUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Zlcy5tYXAoKG1vdmUpID0+IHRoaXMuX21vdmVUb1Nhbihtb3ZlLCBtb3ZlcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9tb3Zlcyh7IGxlZ2FsID0gdHJ1ZSwgcGllY2UgPSB1bmRlZmluZWQsIHNxdWFyZSA9IHVuZGVmaW5lZCwgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGZvclNxdWFyZSA9IHNxdWFyZSA/IHNxdWFyZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBmb3JQaWVjZSA9IHBpZWNlPy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBtb3ZlcyA9IFtdO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICBsZXQgZmlyc3RTcXVhcmUgPSBPeDg4LmE4O1xuICAgICAgICBsZXQgbGFzdFNxdWFyZSA9IE94ODguaDE7XG4gICAgICAgIGxldCBzaW5nbGVTcXVhcmUgPSBmYWxzZTtcbiAgICAgICAgLy8gYXJlIHdlIGdlbmVyYXRpbmcgbW92ZXMgZm9yIGEgc2luZ2xlIHNxdWFyZT9cbiAgICAgICAgaWYgKGZvclNxdWFyZSkge1xuICAgICAgICAgICAgLy8gaWxsZWdhbCBzcXVhcmUsIHJldHVybiBlbXB0eSBtb3Zlc1xuICAgICAgICAgICAgaWYgKCEoZm9yU3F1YXJlIGluIE94ODgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlyc3RTcXVhcmUgPSBsYXN0U3F1YXJlID0gT3g4OFtmb3JTcXVhcmVdO1xuICAgICAgICAgICAgICAgIHNpbmdsZVNxdWFyZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgZnJvbSA9IGZpcnN0U3F1YXJlOyBmcm9tIDw9IGxhc3RTcXVhcmU7IGZyb20rKykge1xuICAgICAgICAgICAgLy8gZGlkIHdlIHJ1biBvZmYgdGhlIGVuZCBvZiB0aGUgYm9hcmRcbiAgICAgICAgICAgIGlmIChmcm9tICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIGZyb20gKz0gNztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVtcHR5IHNxdWFyZSBvciBvcHBvbmVudCwgc2tpcFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFtmcm9tXSB8fCB0aGlzLl9ib2FyZFtmcm9tXS5jb2xvciA9PT0gdGhlbSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0aGlzLl9ib2FyZFtmcm9tXTtcbiAgICAgICAgICAgIGxldCB0bztcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBQQVdOKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgc3F1YXJlLCBub24tY2FwdHVyaW5nXG4gICAgICAgICAgICAgICAgdG8gPSBmcm9tICsgUEFXTl9PRkZTRVRTW3VzXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04pO1xuICAgICAgICAgICAgICAgICAgICAvLyBkb3VibGUgc3F1YXJlXG4gICAgICAgICAgICAgICAgICAgIHRvID0gZnJvbSArIFBBV05fT0ZGU0VUU1t1c11bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChTRUNPTkRfUkFOS1t1c10gPT09IHJhbmsoZnJvbSkgJiYgIXRoaXMuX2JvYXJkW3RvXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCB1bmRlZmluZWQsIEJJVFMuQklHX1BBV04pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHBhd24gY2FwdHVyZXNcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb20gKyBQQVdOX09GRlNFVFNbdXNdW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFt0b10/LmNvbG9yID09PSB0aGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIFBBV04sIHRoaXMuX2JvYXJkW3RvXS50eXBlLCBCSVRTLkNBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSB0aGlzLl9lcFNxdWFyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCBQQVdOLCBQQVdOLCBCSVRTLkVQX0NBUFRVUkUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvclBpZWNlICYmIGZvclBpZWNlICE9PSB0eXBlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgbGVuID0gUElFQ0VfT0ZGU0VUU1t0eXBlXS5sZW5ndGg7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBQSUVDRV9PRkZTRVRTW3R5cGVdW2pdO1xuICAgICAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gJiAweDg4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib2FyZFt0b10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgZnJvbSwgdG8sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duIGNvbG9yLCBzdG9wIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbdG9dLmNvbG9yID09PSB1cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIGZyb20sIHRvLCB0eXBlLCB0aGlzLl9ib2FyZFt0b10udHlwZSwgQklUUy5DQVBUVVJFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGJyZWFrLCBpZiBrbmlnaHQgb3Iga2luZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IEtOSUdIVCB8fCB0eXBlID09PSBLSU5HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGNoZWNrIGZvciBjYXN0bGluZyBpZiB3ZSdyZTpcbiAgICAgICAgICogICBhKSBnZW5lcmF0aW5nIGFsbCBtb3Zlcywgb3JcbiAgICAgICAgICogICBiKSBkb2luZyBzaW5nbGUgc3F1YXJlIG1vdmUgZ2VuZXJhdGlvbiBvbiB0aGUga2luZydzIHNxdWFyZVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZvclBpZWNlID09PSB1bmRlZmluZWQgfHwgZm9yUGllY2UgPT09IEtJTkcpIHtcbiAgICAgICAgICAgIGlmICghc2luZ2xlU3F1YXJlIHx8IGxhc3RTcXVhcmUgPT09IHRoaXMuX2tpbmdzW3VzXSkge1xuICAgICAgICAgICAgICAgIC8vIGtpbmctc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gKyAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSArIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCB0aGlzLl9raW5nc1t1c10pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYXR0YWNrZWQodGhlbSwgY2FzdGxpbmdGcm9tICsgMSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ1RvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTW92ZShtb3ZlcywgdXMsIHRoaXMuX2tpbmdzW3VzXSwgY2FzdGxpbmdUbywgS0lORywgdW5kZWZpbmVkLCBCSVRTLktTSURFX0NBU1RMRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcXVlZW4tc2lkZSBjYXN0bGluZ1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXN0bGluZ1t1c10gJiBCSVRTLlFTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSB0aGlzLl9raW5nc1t1c107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBjYXN0bGluZ0Zyb20gLSAyO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbSAtIDFdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tIC0gMl0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb20gLSAzXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIHRoaXMuX2tpbmdzW3VzXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLl9hdHRhY2tlZCh0aGVtLCBjYXN0bGluZ0Zyb20gLSAxKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXRoaXMuX2F0dGFja2VkKHRoZW0sIGNhc3RsaW5nVG8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRNb3ZlKG1vdmVzLCB1cywgdGhpcy5fa2luZ3NbdXNdLCBjYXN0bGluZ1RvLCBLSU5HLCB1bmRlZmluZWQsIEJJVFMuUVNJREVfQ0FTVExFKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiByZXR1cm4gYWxsIHBzZXVkby1sZWdhbCBtb3ZlcyAodGhpcyBpbmNsdWRlcyBtb3ZlcyB0aGF0IGFsbG93IHRoZSBraW5nXG4gICAgICAgICAqIHRvIGJlIGNhcHR1cmVkKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFsZWdhbCB8fCB0aGlzLl9raW5nc1t1c10gPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbW92ZXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlsdGVyIG91dCBpbGxlZ2FsIG1vdmVzXG4gICAgICAgIGNvbnN0IGxlZ2FsTW92ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG1vdmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3Zlc1tpXSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzS2luZ0F0dGFja2VkKHVzKSkge1xuICAgICAgICAgICAgICAgIGxlZ2FsTW92ZXMucHVzaChtb3Zlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl91bmRvTW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZWdhbE1vdmVzO1xuICAgIH1cbiAgICBtb3ZlKG1vdmUsIHsgc3RyaWN0ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBtb3ZlIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgd2l0aCBpbiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKCdOeGI3JykgICAgICAgPC0gYXJndW1lbnQgaXMgYSBjYXNlLXNlbnNpdGl2ZSBTQU4gc3RyaW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIC5tb3ZlKHsgZnJvbTogJ2g3JywgPC0gYXJndW1lbnQgaXMgYSBtb3ZlIG9iamVjdFxuICAgICAgICAgKiAgICAgICAgIHRvIDonaDgnLFxuICAgICAgICAgKiAgICAgICAgIHByb21vdGlvbjogJ3EnIH0pXG4gICAgICAgICAqXG4gICAgICAgICAqXG4gICAgICAgICAqIEFuIG9wdGlvbmFsIHN0cmljdCBhcmd1bWVudCBtYXkgYmUgc3VwcGxpZWQgdG8gdGVsbCBjaGVzcy5qcyB0b1xuICAgICAgICAgKiBzdHJpY3RseSBmb2xsb3cgdGhlIFNBTiBzcGVjaWZpY2F0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1vdmVPYmogPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIG1vdmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBtb3ZlT2JqID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW92ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVzID0gdGhpcy5fbW92ZXMoKTtcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHByZXR0eSBtb3ZlIG9iamVjdCB0byBhbiB1Z2x5IG1vdmUgb2JqZWN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5mcm9tID09PSBhbGdlYnJhaWMobW92ZXNbaV0uZnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgbW92ZS50byA9PT0gYWxnZWJyYWljKG1vdmVzW2ldLnRvKSAmJlxuICAgICAgICAgICAgICAgICAgICAoISgncHJvbW90aW9uJyBpbiBtb3Zlc1tpXSkgfHwgbW92ZS5wcm9tb3Rpb24gPT09IG1vdmVzW2ldLnByb21vdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZU9iaiA9IG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFpbGVkIHRvIGZpbmQgbW92ZVxuICAgICAgICBpZiAoIW1vdmVPYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW92ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbW92ZTogJHttb3ZlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1vdmU6ICR7SlNPTi5zdHJpbmdpZnkobW92ZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogbmVlZCB0byBtYWtlIGEgY29weSBvZiBtb3ZlIGJlY2F1c2Ugd2UgY2FuJ3QgZ2VuZXJhdGUgU0FOIGFmdGVyIHRoZSBtb3ZlXG4gICAgICAgICAqIGlzIG1hZGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZXR0eU1vdmUgPSB0aGlzLl9tYWtlUHJldHR5KG1vdmVPYmopO1xuICAgICAgICB0aGlzLl9tYWtlTW92ZShtb3ZlT2JqKTtcbiAgICAgICAgcmV0dXJuIHByZXR0eU1vdmU7XG4gICAgfVxuICAgIF9wdXNoKG1vdmUpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeS5wdXNoKHtcbiAgICAgICAgICAgIG1vdmUsXG4gICAgICAgICAgICBraW5nczogeyBiOiB0aGlzLl9raW5ncy5iLCB3OiB0aGlzLl9raW5ncy53IH0sXG4gICAgICAgICAgICB0dXJuOiB0aGlzLl90dXJuLFxuICAgICAgICAgICAgY2FzdGxpbmc6IHsgYjogdGhpcy5fY2FzdGxpbmcuYiwgdzogdGhpcy5fY2FzdGxpbmcudyB9LFxuICAgICAgICAgICAgZXBTcXVhcmU6IHRoaXMuX2VwU3F1YXJlLFxuICAgICAgICAgICAgaGFsZk1vdmVzOiB0aGlzLl9oYWxmTW92ZXMsXG4gICAgICAgICAgICBtb3ZlTnVtYmVyOiB0aGlzLl9tb3ZlTnVtYmVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX21ha2VNb3ZlKG1vdmUpIHtcbiAgICAgICAgY29uc3QgdXMgPSB0aGlzLl90dXJuO1xuICAgICAgICBjb25zdCB0aGVtID0gc3dhcENvbG9yKHVzKTtcbiAgICAgICAgdGhpcy5fcHVzaChtb3ZlKTtcbiAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB0aGlzLl9ib2FyZFttb3ZlLmZyb21dO1xuICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS5mcm9tXTtcbiAgICAgICAgLy8gaWYgZXAgY2FwdHVyZSwgcmVtb3ZlIHRoZSBjYXB0dXJlZCBwYXduXG4gICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5FUF9DQVBUVVJFKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdHVybiA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbbW92ZS50byAtIDE2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFttb3ZlLnRvICsgMTZdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHBhd24gcHJvbW90aW9uLCByZXBsYWNlIHdpdGggbmV3IHBpZWNlXG4gICAgICAgIGlmIChtb3ZlLnByb21vdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fYm9hcmRbbW92ZS50b10gPSB7IHR5cGU6IG1vdmUucHJvbW90aW9uLCBjb2xvcjogdXMgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBtb3ZlZCB0aGUga2luZ1xuICAgICAgICBpZiAodGhpcy5fYm9hcmRbbW92ZS50b10udHlwZSA9PT0gS0lORykge1xuICAgICAgICAgICAgdGhpcy5fa2luZ3NbdXNdID0gbW92ZS50bztcbiAgICAgICAgICAgIC8vIGlmIHdlIGNhc3RsZWQsIG1vdmUgdGhlIHJvb2sgbmV4dCB0byB0aGUga2luZ1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLktTSURFX0NBU1RMRSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhc3RsaW5nVG8gPSBtb3ZlLnRvIC0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ0Zyb20gPSBtb3ZlLnRvICsgMTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSA9IHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FzdGxpbmdGcm9tID0gbW92ZS50byAtIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm9hcmRbY2FzdGxpbmdUb10gPSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ib2FyZFtjYXN0bGluZ0Zyb21dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmdcbiAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3VzXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgbW92ZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3VzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IFJPT0tTW3VzXS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtb3ZlLmZyb20gPT09IFJPT0tTW3VzXVtpXS5zcXVhcmUgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdICYgUk9PS1NbdXNdW2ldLmZsYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbdXNdIF49IFJPT0tTW3VzXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHVybiBvZmYgY2FzdGxpbmcgaWYgd2UgY2FwdHVyZSBhIHJvb2tcbiAgICAgICAgaWYgKHRoaXMuX2Nhc3RsaW5nW3RoZW1dKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gUk9PS1NbdGhlbV0ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS50byA9PT0gUk9PS1NbdGhlbV1baV0uc3F1YXJlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nhc3RsaW5nW3RoZW1dICYgUk9PS1NbdGhlbV1baV0uZmxhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYXN0bGluZ1t0aGVtXSBePSBST09LU1t0aGVtXVtpXS5mbGFnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgYmlnIHBhd24gbW92ZSwgdXBkYXRlIHRoZSBlbiBwYXNzYW50IHNxdWFyZVxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuQklHX1BBV04pIHtcbiAgICAgICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG1vdmUudG8gLSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VwU3F1YXJlID0gbW92ZS50byArIDE2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZXBTcXVhcmUgPSBFTVBUWTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgNTAgbW92ZSBjb3VudGVyIGlmIGEgcGF3biBpcyBtb3ZlZCBvciBhIHBpZWNlIGlzIGNhcHR1cmVkXG4gICAgICAgIGlmIChtb3ZlLnBpZWNlID09PSBQQVdOKSB7XG4gICAgICAgICAgICB0aGlzLl9oYWxmTW92ZXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1vdmUuZmxhZ3MgJiAoQklUUy5DQVBUVVJFIHwgQklUUy5FUF9DQVBUVVJFKSkge1xuICAgICAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbGZNb3ZlcysrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cyA9PT0gQkxBQ0spIHtcbiAgICAgICAgICAgIHRoaXMuX21vdmVOdW1iZXIrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90dXJuID0gdGhlbTtcbiAgICB9XG4gICAgdW5kbygpIHtcbiAgICAgICAgY29uc3QgbW92ZSA9IHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBtb3ZlID8gdGhpcy5fbWFrZVByZXR0eShtb3ZlKSA6IG51bGw7XG4gICAgfVxuICAgIF91bmRvTW92ZSgpIHtcbiAgICAgICAgY29uc3Qgb2xkID0gdGhpcy5faGlzdG9yeS5wb3AoKTtcbiAgICAgICAgaWYgKG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb3ZlID0gb2xkLm1vdmU7XG4gICAgICAgIHRoaXMuX2tpbmdzID0gb2xkLmtpbmdzO1xuICAgICAgICB0aGlzLl90dXJuID0gb2xkLnR1cm47XG4gICAgICAgIHRoaXMuX2Nhc3RsaW5nID0gb2xkLmNhc3RsaW5nO1xuICAgICAgICB0aGlzLl9lcFNxdWFyZSA9IG9sZC5lcFNxdWFyZTtcbiAgICAgICAgdGhpcy5faGFsZk1vdmVzID0gb2xkLmhhbGZNb3ZlcztcbiAgICAgICAgdGhpcy5fbW92ZU51bWJlciA9IG9sZC5tb3ZlTnVtYmVyO1xuICAgICAgICBjb25zdCB1cyA9IHRoaXMuX3R1cm47XG4gICAgICAgIGNvbnN0IHRoZW0gPSBzd2FwQ29sb3IodXMpO1xuICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLmZyb21dID0gdGhpcy5fYm9hcmRbbW92ZS50b107XG4gICAgICAgIHRoaXMuX2JvYXJkW21vdmUuZnJvbV0udHlwZSA9IG1vdmUucGllY2U7IC8vIHRvIHVuZG8gYW55IHByb21vdGlvbnNcbiAgICAgICAgZGVsZXRlIHRoaXMuX2JvYXJkW21vdmUudG9dO1xuICAgICAgICBpZiAobW92ZS5jYXB0dXJlZCkge1xuICAgICAgICAgICAgaWYgKG1vdmUuZmxhZ3MgJiBCSVRTLkVQX0NBUFRVUkUpIHtcbiAgICAgICAgICAgICAgICAvLyBlbiBwYXNzYW50IGNhcHR1cmVcbiAgICAgICAgICAgICAgICBsZXQgaW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHVzID09PSBCTEFDSykge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IG1vdmUudG8gLSAxNjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gbW92ZS50byArIDE2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFtpbmRleF0gPSB7IHR5cGU6IFBBV04sIGNvbG9yOiB0aGVtIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZWd1bGFyIGNhcHR1cmVcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2FyZFttb3ZlLnRvXSA9IHsgdHlwZTogbW92ZS5jYXB0dXJlZCwgY29sb3I6IHRoZW0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZS5mbGFncyAmIChCSVRTLktTSURFX0NBU1RMRSB8IEJJVFMuUVNJREVfQ0FTVExFKSkge1xuICAgICAgICAgICAgbGV0IGNhc3RsaW5nVG8sIGNhc3RsaW5nRnJvbTtcbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgQklUUy5LU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ1RvID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdGcm9tID0gbW92ZS50byAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYXN0bGluZ1RvID0gbW92ZS50byAtIDI7XG4gICAgICAgICAgICAgICAgY2FzdGxpbmdGcm9tID0gbW92ZS50byArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib2FyZFtjYXN0bGluZ1RvXSA9IHRoaXMuX2JvYXJkW2Nhc3RsaW5nRnJvbV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYm9hcmRbY2FzdGxpbmdGcm9tXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW92ZTtcbiAgICB9XG4gICAgcGduKHsgbmV3bGluZSA9ICdcXG4nLCBtYXhXaWR0aCA9IDAsIH0gPSB7fSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiB1c2luZyB0aGUgc3BlY2lmaWNhdGlvbiBmcm9tIGh0dHA6Ly93d3cuY2hlc3NjbHViLmNvbS9oZWxwL1BHTi1zcGVjXG4gICAgICAgICAqIGV4YW1wbGUgZm9yIGh0bWwgdXNhZ2U6IC5wZ24oeyBtYXhfd2lkdGg6IDcyLCBuZXdsaW5lX2NoYXI6IFwiPGJyIC8+XCIgfSlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaGVhZGVyRXhpc3RzID0gZmFsc2U7XG4gICAgICAgIC8qIGFkZCB0aGUgUEdOIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5faGVhZGVyKSB7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVE9ETzogb3JkZXIgb2YgZW51bWVyYXRlZCBwcm9wZXJ0aWVzIGluIGhlYWRlciBvYmplY3QgaXMgbm90XG4gICAgICAgICAgICAgKiBndWFyYW50ZWVkLCBzZWUgRUNNQS0yNjIgc3BlYyAoc2VjdGlvbiAxMi42LjQpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCdbJyArIGkgKyAnIFwiJyArIHRoaXMuX2hlYWRlcltpXSArICdcIl0nICsgbmV3bGluZSk7XG4gICAgICAgICAgICBoZWFkZXJFeGlzdHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJFeGlzdHMgJiYgdGhpcy5faGlzdG9yeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZENvbW1lbnQgPSAobW92ZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21tZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlciA9IG1vdmVTdHJpbmcubGVuZ3RoID4gMCA/ICcgJyA6ICcnO1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBgJHttb3ZlU3RyaW5nfSR7ZGVsaW1pdGVyfXske2NvbW1lbnR9fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbW92ZVN0cmluZztcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcG9wIGFsbCBvZiBoaXN0b3J5IG9udG8gcmV2ZXJzZWRfaGlzdG9yeVxuICAgICAgICBjb25zdCByZXZlcnNlZEhpc3RvcnkgPSBbXTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV2ZXJzZWRIaXN0b3J5LnB1c2godGhpcy5fdW5kb01vdmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW92ZXMgPSBbXTtcbiAgICAgICAgbGV0IG1vdmVTdHJpbmcgPSAnJztcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIG9mIGEgY29tbWVudGVkIHN0YXJ0aW5nIHBvc2l0aW9uIHdpdGggbm8gbW92ZXNcbiAgICAgICAgaWYgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG1vdmVzLnB1c2goYXBwZW5kQ29tbWVudCgnJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBsaXN0IG9mIG1vdmVzLiAgYSBtb3ZlX3N0cmluZyBsb29rcyBsaWtlOiBcIjMuIGUzIGU2XCJcbiAgICAgICAgd2hpbGUgKHJldmVyc2VkSGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID0gYXBwZW5kQ29tbWVudChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IG1vdmUgPSByZXZlcnNlZEhpc3RvcnkucG9wKCk7XG4gICAgICAgICAgICAvLyBtYWtlIFR5cGVTY3JpcHQgc3RvcCBjb21wbGFpbmluZyBhYm91dCBtb3ZlIGJlaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9zaXRpb24gc3RhcnRlZCB3aXRoIGJsYWNrIHRvIG1vdmUsIHN0YXJ0IFBHTiB3aXRoICMuIC4uLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9oaXN0b3J5Lmxlbmd0aCAmJiBtb3ZlLmNvbG9yID09PSAnYicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXggPSBgJHt0aGlzLl9tb3ZlTnVtYmVyfS4gLi4uYDtcbiAgICAgICAgICAgICAgICAvLyBpcyB0aGVyZSBhIGNvbW1lbnQgcHJlY2VkaW5nIHRoZSBmaXJzdCBtb3ZlP1xuICAgICAgICAgICAgICAgIG1vdmVTdHJpbmcgPSBtb3ZlU3RyaW5nID8gYCR7bW92ZVN0cmluZ30gJHtwcmVmaXh9YCA6IHByZWZpeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1vdmUuY29sb3IgPT09ICd3Jykge1xuICAgICAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBwcmV2aW91cyBnZW5lcmF0ZWQgbW92ZV9zdHJpbmcgaWYgd2UgaGF2ZSBvbmVcbiAgICAgICAgICAgICAgICBpZiAobW92ZVN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbW92ZXMucHVzaChtb3ZlU3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW92ZVN0cmluZyA9IHRoaXMuX21vdmVOdW1iZXIgKyAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtb3ZlU3RyaW5nID1cbiAgICAgICAgICAgICAgICBtb3ZlU3RyaW5nICsgJyAnICsgdGhpcy5fbW92ZVRvU2FuKG1vdmUsIHRoaXMuX21vdmVzKHsgbGVnYWw6IHRydWUgfSkpO1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXJlIHRoZXJlIGFueSBvdGhlciBsZWZ0b3ZlciBtb3Zlcz9cbiAgICAgICAgaWYgKG1vdmVTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKGFwcGVuZENvbW1lbnQobW92ZVN0cmluZykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzIHRoZXJlIGEgcmVzdWx0P1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2hlYWRlci5SZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBtb3Zlcy5wdXNoKHRoaXMuX2hlYWRlci5SZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIGhpc3Rvcnkgc2hvdWxkIGJlIGJhY2sgdG8gd2hhdCBpdCB3YXMgYmVmb3JlIHdlIHN0YXJ0ZWQgZ2VuZXJhdGluZyBQR04sXG4gICAgICAgICAqIHNvIGpvaW4gdG9nZXRoZXIgbW92ZXNcbiAgICAgICAgICovXG4gICAgICAgIGlmIChtYXhXaWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKSArIG1vdmVzLmpvaW4oJyAnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIChqYWgpOiBodWg/XG4gICAgICAgIGNvbnN0IHN0cmlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwICYmIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gTkI6IHRoaXMgZG9lcyBub3QgcHJlc2VydmUgY29tbWVudCB3aGl0ZXNwYWNlLlxuICAgICAgICBjb25zdCB3cmFwQ29tbWVudCA9IGZ1bmN0aW9uICh3aWR0aCwgbW92ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBtb3ZlLnNwbGl0KCcgJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2lkdGggKyB0b2tlbi5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RyaXAoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgd2lkdGggKz0gdG9rZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKCcgJyk7XG4gICAgICAgICAgICAgICAgd2lkdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpcCgpKSB7XG4gICAgICAgICAgICAgICAgd2lkdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aWR0aDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd3JhcCB0aGUgUEdOIG91dHB1dCBhdCBtYXhfd2lkdGhcbiAgICAgICAgbGV0IGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50V2lkdGggKyBtb3Zlc1tpXS5sZW5ndGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtb3Zlc1tpXS5pbmNsdWRlcygneycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IHdyYXBDb21tZW50KGN1cnJlbnRXaWR0aCwgbW92ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBtb3ZlIHdpbGwgcHVzaCBwYXN0IG1heF93aWR0aFxuICAgICAgICAgICAgaWYgKGN1cnJlbnRXaWR0aCArIG1vdmVzW2ldLmxlbmd0aCA+IG1heFdpZHRoICYmIGkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBkb24ndCBlbmQgdGhlIGxpbmUgd2l0aCB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPT09ICcgJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld2xpbmUpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXaWR0aCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goJyAnKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50V2lkdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1vdmVzW2ldKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaWR0aCArPSBtb3Zlc1tpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbiAgICB9XG4gICAgaGVhZGVyKC4uLmFyZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBhcmdzW2kgKyAxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkZXJbYXJnc1tpXV0gPSBhcmdzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faGVhZGVyO1xuICAgIH1cbiAgICBsb2FkUGduKHBnbiwgeyBzdHJpY3QgPSBmYWxzZSwgbmV3bGluZUNoYXIgPSAnXFxyP1xcbicsIH0gPSB7fSkge1xuICAgICAgICBmdW5jdGlvbiBtYXNrKHN0cikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxcL2csICdcXFxcJyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VQZ25IZWFkZXIoaGVhZGVyKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJPYmogPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBoZWFkZXIuc3BsaXQobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVDaGFyKSkpO1xuICAgICAgICAgICAgbGV0IGtleSA9ICcnO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IC9eXFxzKlxcW1xccyooW0EtWmEtel0rKVxccypcIiguKilcIlxccypcXF1cXHMqJC87XG4gICAgICAgICAgICAgICAga2V5ID0gaGVhZGVyc1tpXS5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGhlYWRlcnNbaV0ucmVwbGFjZShyZWdleCwgJyQyJyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50cmltKCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJPYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZWFkZXJPYmo7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyaXAgd2hpdGVzcGFjZSBmcm9tIGhlYWQvdGFpbCBvZiBQR04gYmxvY2tcbiAgICAgICAgcGduID0gcGduLnRyaW0oKTtcbiAgICAgICAgLypcbiAgICAgICAgICogUmVnRXhwIHRvIHNwbGl0IGhlYWRlci4gVGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgaGVhZGVyIGFuZCBtb3ZldGV4dFxuICAgICAgICAgKiB3aWxsIGFsd2F5cyBoYXZlIGEgYmxhbmsgbGluZSBiZXR3ZWVuIHRoZW0gKGllLCB0d28gbmV3bGluZV9jaGFyJ3MpLiBIYW5kbGVzXG4gICAgICAgICAqIGNhc2Ugd2hlcmUgbW92ZXRleHQgaXMgZW1wdHkgYnkgbWF0Y2hpbmcgbmV3bGluZUNoYXIgdW50aWwgZW5kIG9mIHN0cmluZyBpc1xuICAgICAgICAgKiBtYXRjaGVkIC0gZWZmZWN0aXZlbHkgdHJpbW1pbmcgZnJvbSB0aGUgZW5kIGV4dHJhIG5ld2xpbmVDaGFyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaXRoIGRlZmF1bHQgbmV3bGluZV9jaGFyLCB3aWxsIGVxdWFsOlxuICAgICAgICAgKiAvXihcXFsoKD86XFxyP1xcbil8LikqXFxdKSgoPzpcXHMqXFxyP1xcbil7Mn18KD86XFxzKlxccj9cXG4pKiQpL1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaGVhZGVyUmVnZXggPSBuZXcgUmVnRXhwKCdeKFxcXFxbKCg/OicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJyl8LikqXFxcXF0pJyArXG4gICAgICAgICAgICAnKCg/OlxcXFxzKicgK1xuICAgICAgICAgICAgbWFzayhuZXdsaW5lQ2hhcikgK1xuICAgICAgICAgICAgJyl7Mn18KD86XFxcXHMqJyArXG4gICAgICAgICAgICBtYXNrKG5ld2xpbmVDaGFyKSArXG4gICAgICAgICAgICAnKSokKScpO1xuICAgICAgICAvLyBJZiBubyBoZWFkZXIgZ2l2ZW4sIGJlZ2luIHdpdGggbW92ZXMuXG4gICAgICAgIGNvbnN0IGhlYWRlclJlZ2V4UmVzdWx0cyA9IGhlYWRlclJlZ2V4LmV4ZWMocGduKTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RyaW5nID0gaGVhZGVyUmVnZXhSZXN1bHRzXG4gICAgICAgICAgICA/IGhlYWRlclJlZ2V4UmVzdWx0cy5sZW5ndGggPj0gMlxuICAgICAgICAgICAgICAgID8gaGVhZGVyUmVnZXhSZXN1bHRzWzFdXG4gICAgICAgICAgICAgICAgOiAnJ1xuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgLy8gUHV0IHRoZSBib2FyZCBpbiB0aGUgc3RhcnRpbmcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAvLyBwYXJzZSBQR04gaGVhZGVyXG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBwYXJzZVBnbkhlYWRlcihoZWFkZXJTdHJpbmcpO1xuICAgICAgICBsZXQgZmVuID0gJyc7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRvIHNlZSB1c2VyIGlzIGluY2x1ZGluZyBmZW4gKHBvc3NpYmx5IHdpdGggd3JvbmcgdGFnIGNhc2UpXG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09ICdmZW4nKSB7XG4gICAgICAgICAgICAgICAgZmVuID0gaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIHRoZSBwZXJtaXNzaXZlIHBhcnNlciBzaG91bGQgYXR0ZW1wdCB0byBsb2FkIGEgZmVuIHRhZywgZXZlbiBpZiBpdCdzIHRoZVxuICAgICAgICAgKiB3cm9uZyBjYXNlIGFuZCBkb2Vzbid0IGluY2x1ZGUgYSBjb3JyZXNwb25kaW5nIFtTZXRVcCBcIjFcIl0gdGFnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZlbikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChmZW4sIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIHN0cmljdCBwYXJzZXIgLSBsb2FkIHRoZSBzdGFydGluZyBwb3NpdGlvbiBpbmRpY2F0ZWQgYnkgW1NldHVwICcxJ11cbiAgICAgICAgICAgICAqIGFuZCBbRkVOIHBvc2l0aW9uXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1snU2V0VXAnXSA9PT0gJzEnKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoJ0ZFTicgaW4gaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFBHTjogRkVOIHRhZyBtdXN0IGJlIHN1cHBsaWVkIHdpdGggU2V0VXAgdGFnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNlY29uZCBhcmd1bWVudCB0byBsb2FkOiBkb24ndCBjbGVhciB0aGUgaGVhZGVyc1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZChoZWFkZXJzWydGRU4nXSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogTkI6IHRoZSByZWdleGVzIGJlbG93IHRoYXQgZGVsZXRlIG1vdmUgbnVtYmVycywgcmVjdXJzaXZlIGFubm90YXRpb25zLFxuICAgICAgICAgKiBhbmQgbnVtZXJpYyBhbm5vdGF0aW9uIGdseXBocyBtYXkgYWxzbyBtYXRjaCB0ZXh0IGluIGNvbW1lbnRzLiBUb1xuICAgICAgICAgKiBwcmV2ZW50IHRoaXMsIHdlIHRyYW5zZm9ybSBjb21tZW50cyBieSBoZXgtZW5jb2RpbmcgdGhlbSBpbiBwbGFjZSBhbmRcbiAgICAgICAgICogZGVjb2RpbmcgdGhlbSBhZ2FpbiBhZnRlciB0aGUgb3RoZXIgdG9rZW5zIGhhdmUgYmVlbiBkZWxldGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGlsZSB0aGUgc3BlYyBzdGF0ZXMgdGhhdCBQR04gZmlsZXMgc2hvdWxkIGJlIEFTQ0lJIGVuY29kZWQsIHdlIHVzZVxuICAgICAgICAgKiB7ZW4sZGV9Y29kZVVSSUNvbXBvbmVudCBoZXJlIHRvIHN1cHBvcnQgYXJiaXRyYXJ5IFVURjggYXMgYSBjb252ZW5pZW5jZVxuICAgICAgICAgKiBmb3IgbW9kZXJuIHVzZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB0b0hleChzKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGVuY29kZVVSSSBkb2Vzbid0IHRyYW5zZm9ybSBtb3N0IEFTQ0lJIGNoYXJhY3RlcnMsIHNvIHdlIGhhbmRsZVxuICAgICAgICAgICAgICAgICAqIHRoZXNlIG91cnNlbHZlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgPCAxMjhcbiAgICAgICAgICAgICAgICAgICAgPyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50KGMpLnJlcGxhY2UoLyUvZywgJycpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmcm9tSGV4KHMpIHtcbiAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aCA9PSAwXG4gICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgIDogZGVjb2RlVVJJQ29tcG9uZW50KCclJyArIChzLm1hdGNoKC8uezEsMn0vZykgfHwgW10pLmpvaW4oJyUnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlQ29tbWVudCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKG5ldyBSZWdFeHAobWFzayhuZXdsaW5lQ2hhciksICdnJyksICcgJyk7XG4gICAgICAgICAgICByZXR1cm4gYHske3RvSGV4KHMuc2xpY2UoMSwgcy5sZW5ndGggLSAxKSl9fWA7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlY29kZUNvbW1lbnQgPSBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgaWYgKHMuc3RhcnRzV2l0aCgneycpICYmIHMuZW5kc1dpdGgoJ30nKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcm9tSGV4KHMuc2xpY2UoMSwgcy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlbGV0ZSBoZWFkZXIgdG8gZ2V0IHRoZSBtb3Zlc1xuICAgICAgICBsZXQgbXMgPSBwZ25cbiAgICAgICAgICAgIC5yZXBsYWNlKGhlYWRlclN0cmluZywgJycpXG4gICAgICAgICAgICAucmVwbGFjZShcbiAgICAgICAgLy8gZW5jb2RlIGNvbW1lbnRzIHNvIHRoZXkgZG9uJ3QgZ2V0IGRlbGV0ZWQgYmVsb3dcbiAgICAgICAgbmV3IFJlZ0V4cChgKHtbXn1dKn0pKz98OyhbXiR7bWFzayhuZXdsaW5lQ2hhcil9XSopYCwgJ2cnKSwgZnVuY3Rpb24gKF9tYXRjaCwgYnJhY2tldCwgc2VtaWNvbG9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJhY2tldCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBlbmNvZGVDb21tZW50KGJyYWNrZXQpXG4gICAgICAgICAgICAgICAgOiAnICcgKyBlbmNvZGVDb21tZW50KGB7JHtzZW1pY29sb24uc2xpY2UoMSl9fWApO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UobmV3IFJlZ0V4cChtYXNrKG5ld2xpbmVDaGFyKSwgJ2cnKSwgJyAnKTtcbiAgICAgICAgLy8gZGVsZXRlIHJlY3Vyc2l2ZSBhbm5vdGF0aW9uIHZhcmlhdGlvbnNcbiAgICAgICAgY29uc3QgcmF2UmVnZXggPSAvKFxcKFteKCldK1xcKSkrPy9nO1xuICAgICAgICB3aGlsZSAocmF2UmVnZXgudGVzdChtcykpIHtcbiAgICAgICAgICAgIG1zID0gbXMucmVwbGFjZShyYXZSZWdleCwgJycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRlbGV0ZSBtb3ZlIG51bWJlcnNcbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXGQrXFwuKFxcLlxcLik/L2csICcnKTtcbiAgICAgICAgLy8gZGVsZXRlIC4uLiBpbmRpY2F0aW5nIGJsYWNrIHRvIG1vdmVcbiAgICAgICAgbXMgPSBtcy5yZXBsYWNlKC9cXC5cXC5cXC4vZywgJycpO1xuICAgICAgICAvKiBkZWxldGUgbnVtZXJpYyBhbm5vdGF0aW9uIGdseXBocyAqL1xuICAgICAgICBtcyA9IG1zLnJlcGxhY2UoL1xcJFxcZCsvZywgJycpO1xuICAgICAgICAvLyB0cmltIGFuZCBnZXQgYXJyYXkgb2YgbW92ZXNcbiAgICAgICAgbGV0IG1vdmVzID0gbXMudHJpbSgpLnNwbGl0KG5ldyBSZWdFeHAoL1xccysvKSk7XG4gICAgICAgIC8vIGRlbGV0ZSBlbXB0eSBlbnRyaWVzXG4gICAgICAgIG1vdmVzID0gbW92ZXMuZmlsdGVyKChtb3ZlKSA9PiBtb3ZlICE9PSAnJyk7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaGFsZk1vdmUgPSAwOyBoYWxmTW92ZSA8IG1vdmVzLmxlbmd0aDsgaGFsZk1vdmUrKykge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IGRlY29kZUNvbW1lbnQobW92ZXNbaGFsZk1vdmVdKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXSA9IGNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gdGhpcy5fbW92ZUZyb21TYW4obW92ZXNbaGFsZk1vdmVdLCBzdHJpY3QpO1xuICAgICAgICAgICAgLy8gaW52YWxpZCBtb3ZlXG4gICAgICAgICAgICBpZiAobW92ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2FzIHRoZSBtb3ZlIGFuIGVuZCBvZiBnYW1lIG1hcmtlclxuICAgICAgICAgICAgICAgIGlmIChURVJNSU5BVElPTl9NQVJLRVJTLmluZGV4T2YobW92ZXNbaGFsZk1vdmVdKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1vdmVzW2hhbGZNb3ZlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBtb3ZlIGluIFBHTjogJHttb3Zlc1toYWxmTW92ZV19YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGVuZCBvZiBnYW1lIG1hcmtlciBpZiBtYWtpbmcgYSB2YWxpZCBtb3ZlXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogUGVyIHNlY3Rpb24gOC4yLjYgb2YgdGhlIFBHTiBzcGVjLCB0aGUgUmVzdWx0IHRhZyBwYWlyIG11c3QgbWF0Y2ggbWF0Y2hcbiAgICAgICAgICogdGhlIHRlcm1pbmF0aW9uIG1hcmtlci4gT25seSBkbyB0aGlzIHdoZW4gaGVhZGVycyBhcmUgcHJlc2VudCwgYnV0IHRoZVxuICAgICAgICAgKiByZXN1bHQgdGFnIGlzIG1pc3NpbmdcbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXN1bHQgJiYgT2JqZWN0LmtleXModGhpcy5faGVhZGVyKS5sZW5ndGggJiYgIXRoaXMuX2hlYWRlclsnUmVzdWx0J10pIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyKCdSZXN1bHQnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qXG4gICAgICogQ29udmVydCBhIG1vdmUgZnJvbSAweDg4IGNvb3JkaW5hdGVzIHRvIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvblxuICAgICAqIChTQU4pXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHN0cmljdCBVc2UgdGhlIHN0cmljdCBTQU4gcGFyc2VyLiBJdCB3aWxsIHRocm93IGVycm9yc1xuICAgICAqIG9uIG92ZXJseSBkaXNhbWJpZ3VhdGVkIG1vdmVzIChzZWUgYmVsb3cpOlxuICAgICAqXG4gICAgICogcjFicWtibnIvcHBwMnBwcC8ybjUvMUIxcFAzLzRQMy84L1BQUFAyUFAvUk5CUUsxTlIgYiBLUWtxIC0gMiA0XG4gICAgICogNC4gLi4uIE5nZTcgaXMgb3Zlcmx5IGRpc2FtYmlndWF0ZWQgYmVjYXVzZSB0aGUga25pZ2h0IG9uIGM2IGlzIHBpbm5lZFxuICAgICAqIDQuIC4uLiBOZTcgaXMgdGVjaG5pY2FsbHkgdGhlIHZhbGlkIFNBTlxuICAgICAqL1xuICAgIF9tb3ZlVG9TYW4obW92ZSwgbW92ZXMpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9ICcnO1xuICAgICAgICBpZiAobW92ZS5mbGFncyAmIEJJVFMuS1NJREVfQ0FTVExFKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSAnTy1PJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtb3ZlLmZsYWdzICYgQklUUy5RU0lERV9DQVNUTEUpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICdPLU8tTyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW92ZS5waWVjZSAhPT0gUEFXTikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FtYmlndWF0b3IgPSBnZXREaXNhbWJpZ3VhdG9yKG1vdmUsIG1vdmVzKTtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gbW92ZS5waWVjZS50b1VwcGVyQ2FzZSgpICsgZGlzYW1iaWd1YXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb3ZlLmZsYWdzICYgKEJJVFMuQ0FQVFVSRSB8IEJJVFMuRVBfQ0FQVFVSRSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobW92ZS5waWVjZSA9PT0gUEFXTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUuZnJvbSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dCArPSAneCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXQgKz0gYWxnZWJyYWljKG1vdmUudG8pO1xuICAgICAgICAgICAgaWYgKG1vdmUucHJvbW90aW9uKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICc9JyArIG1vdmUucHJvbW90aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIGlmICh0aGlzLmlzQ2hlY2soKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDaGVja21hdGUoKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSAnIyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJysnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIC8vIGNvbnZlcnQgYSBtb3ZlIGZyb20gU3RhbmRhcmQgQWxnZWJyYWljIE5vdGF0aW9uIChTQU4pIHRvIDB4ODggY29vcmRpbmF0ZXNcbiAgICBfbW92ZUZyb21TYW4obW92ZSwgc3RyaWN0ID0gZmFsc2UpIHtcbiAgICAgICAgLy8gc3RyaXAgb2ZmIGFueSBtb3ZlIGRlY29yYXRpb25zOiBlLmcgTmYzKz8hIGJlY29tZXMgTmYzXG4gICAgICAgIGNvbnN0IGNsZWFuTW92ZSA9IHN0cmlwcGVkU2FuKG1vdmUpO1xuICAgICAgICBsZXQgcGllY2VUeXBlID0gaW5mZXJQaWVjZVR5cGUoY2xlYW5Nb3ZlKTtcbiAgICAgICAgbGV0IG1vdmVzID0gdGhpcy5fbW92ZXMoeyBsZWdhbDogdHJ1ZSwgcGllY2U6IHBpZWNlVHlwZSB9KTtcbiAgICAgICAgLy8gc3RyaWN0IHBhcnNlclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjbGVhbk1vdmUgPT09IHN0cmlwcGVkU2FuKHRoaXMuX21vdmVUb1Nhbihtb3Zlc1tpXSwgbW92ZXMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgc3RyaWN0IHBhcnNlciBmYWlsZWRcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBpZWNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgbWF0Y2hlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB0byA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHByb21vdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGRlZmF1bHQgcGVybWlzc2l2ZSAobm9uLXN0cmljdCkgcGFyc2VyIGFsbG93cyB0aGUgdXNlciB0byBwYXJzZVxuICAgICAgICAgKiBub24tc3RhbmRhcmQgY2hlc3Mgbm90YXRpb25zLiBUaGlzIHBhcnNlciBpcyBvbmx5IHJ1biBhZnRlciB0aGUgc3RyaWN0XG4gICAgICAgICAqIFN0YW5kYXJkIEFsZ2VicmFpYyBOb3RhdGlvbiAoU0FOKSBwYXJzZXIgaGFzIGZhaWxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiBydW5uaW5nIHRoZSBwZXJtaXNzaXZlIHBhcnNlciwgd2UnbGwgcnVuIGEgcmVnZXggdG8gZ3JhYiB0aGUgcGllY2UsIHRoZVxuICAgICAgICAgKiB0by9mcm9tIHNxdWFyZSwgYW5kIGFuIG9wdGlvbmFsIHByb21vdGlvbiBwaWVjZS4gVGhpcyByZWdleCB3aWxsXG4gICAgICAgICAqIHBhcnNlIGNvbW1vbiBub24tc3RhbmRhcmQgbm90YXRpb24gbGlrZTogUGUyLWU0LCBSYzFjNCwgUWYzeGY3LFxuICAgICAgICAgKiBmN2Y4cSwgYjFjM1xuICAgICAgICAgKlxuICAgICAgICAgKiBOT1RFOiBTb21lIHBvc2l0aW9ucyBhbmQgbW92ZXMgbWF5IGJlIGFtYmlndW91cyB3aGVuIHVzaW5nIHRoZSBwZXJtaXNzaXZlXG4gICAgICAgICAqIHBhcnNlci4gRm9yIGV4YW1wbGUsIGluIHRoaXMgcG9zaXRpb246IDZrMS84LzgvQjcvOC84LzgvQk40SzEgdyAtIC0gMCAxLFxuICAgICAgICAgKiB0aGUgbW92ZSBiMWMzIG1heSBiZSBpbnRlcnByZXRlZCBhcyBOYzMgb3IgQjFjMyAoYSBkaXNhbWJpZ3VhdGVkIGJpc2hvcFxuICAgICAgICAgKiBtb3ZlKS4gSW4gdGhlc2UgY2FzZXMsIHRoZSBwZXJtaXNzaXZlIHBhcnNlciB3aWxsIGRlZmF1bHQgdG8gdGhlIG1vc3RcbiAgICAgICAgICogYmFzaWMgaW50ZXJwcmV0YXRpb24gKHdoaWNoIGlzIGIxYzMgcGFyc2luZyB0byBOYzMpLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG92ZXJseURpc2FtYmlndWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hlcyA9IGNsZWFuTW92ZS5tYXRjaCgvKFtwbmJycWtQTkJSUUtdKT8oW2EtaF1bMS04XSl4Py0/KFthLWhdWzEtOF0pKFtxcmJuUVJCTl0pPy9cbiAgICAgICAgLy8gICAgIHBpZWNlICAgICAgICAgZnJvbSAgICAgICAgICAgICAgdG8gICAgICAgcHJvbW90aW9uXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICBwaWVjZSA9IG1hdGNoZXNbMV07XG4gICAgICAgICAgICBmcm9tID0gbWF0Y2hlc1syXTtcbiAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgIHByb21vdGlvbiA9IG1hdGNoZXNbNF07XG4gICAgICAgICAgICBpZiAoZnJvbS5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBbYS1oXT9bMS04XT8gcG9ydGlvbiBvZiB0aGUgcmVnZXggYmVsb3cgaGFuZGxlcyBtb3ZlcyB0aGF0IG1heSBiZVxuICAgICAgICAgICAgICogb3Zlcmx5IGRpc2FtYmlndWF0ZWQgKGUuZy4gTmdlNyBpcyB1bm5lY2Vzc2FyeSBhbmQgbm9uLXN0YW5kYXJkIHdoZW5cbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG9uZSBsZWdhbCBrbmlnaHQgbW92ZSB0byBlNykuIEluIHRoaXMgY2FzZSwgdGhlIHZhbHVlIG9mXG4gICAgICAgICAgICAgKiAnZnJvbScgdmFyaWFibGUgd2lsbCBiZSBhIHJhbmsgb3IgZmlsZSwgbm90IGEgc3F1YXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtYXRjaGVzID0gY2xlYW5Nb3ZlLm1hdGNoKC8oW3BuYnJxa1BOQlJRS10pPyhbYS1oXT9bMS04XT8peD8tPyhbYS1oXVsxLThdKShbcXJiblFSQk5dKT8vKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgcGllY2UgPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgICAgIGZyb20gPSBtYXRjaGVzWzJdO1xuICAgICAgICAgICAgICAgIHRvID0gbWF0Y2hlc1szXTtcbiAgICAgICAgICAgICAgICBwcm9tb3Rpb24gPSBtYXRjaGVzWzRdO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJseURpc2FtYmlndWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwaWVjZVR5cGUgPSBpbmZlclBpZWNlVHlwZShjbGVhbk1vdmUpO1xuICAgICAgICBtb3ZlcyA9IHRoaXMuX21vdmVzKHtcbiAgICAgICAgICAgIGxlZ2FsOiB0cnVlLFxuICAgICAgICAgICAgcGllY2U6IHBpZWNlID8gcGllY2UgOiBwaWVjZVR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRvKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbW92ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZyb20gc3F1YXJlLCBpdCBjb3VsZCBiZSBqdXN0ICd4JyBtaXNzaW5nIGZyb20gYSBjYXB0dXJlXG4gICAgICAgICAgICAgICAgaWYgKGNsZWFuTW92ZSA9PT0gc3RyaXBwZWRTYW4odGhpcy5fbW92ZVRvU2FuKG1vdmVzW2ldLCBtb3ZlcykpLnJlcGxhY2UoJ3gnLCAnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vdmVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kLWNvbXBhcmUgbW92ZSBwcm9wZXJ0aWVzIHdpdGggdGhlIHJlc3VsdHMgZnJvbSBvdXIgcGVybWlzc2l2ZSByZWdleFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKCFwaWVjZSB8fCBwaWVjZS50b0xvd2VyQ2FzZSgpID09IG1vdmVzW2ldLnBpZWNlKSAmJlxuICAgICAgICAgICAgICAgIE94ODhbZnJvbV0gPT0gbW92ZXNbaV0uZnJvbSAmJlxuICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb3Zlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJseURpc2FtYmlndWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFNQRUNJQUwgQ0FTRTogd2UgcGFyc2VkIGEgbW92ZSBzdHJpbmcgdGhhdCBtYXkgaGF2ZSBhbiB1bm5lZWRlZFxuICAgICAgICAgICAgICAgICAqIHJhbmsvZmlsZSBkaXNhbWJpZ3VhdG9yIChlLmcuIE5nZTcpLiAgVGhlICdmcm9tJyB2YXJpYWJsZSB3aWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3Qgc3F1YXJlID0gYWxnZWJyYWljKG1vdmVzW2ldLmZyb20pO1xuICAgICAgICAgICAgICAgIGlmICgoIXBpZWNlIHx8IHBpZWNlLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucGllY2UpICYmXG4gICAgICAgICAgICAgICAgICAgIE94ODhbdG9dID09IG1vdmVzW2ldLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIChmcm9tID09IHNxdWFyZVswXSB8fCBmcm9tID09IHNxdWFyZVsxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9tb3Rpb24gfHwgcHJvbW90aW9uLnRvTG93ZXJDYXNlKCkgPT0gbW92ZXNbaV0ucHJvbW90aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW92ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhc2NpaSgpIHtcbiAgICAgICAgbGV0IHMgPSAnICAgKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcXG4nO1xuICAgICAgICBmb3IgKGxldCBpID0gT3g4OC5hODsgaSA8PSBPeDg4LmgxOyBpKyspIHtcbiAgICAgICAgICAgIC8vIGRpc3BsYXkgdGhlIHJhbmtcbiAgICAgICAgICAgIGlmIChmaWxlKGkpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICcgKyAnODc2NTQzMjEnW3JhbmsoaSldICsgJyB8JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2FyZFtpXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpZWNlID0gdGhpcy5fYm9hcmRbaV0udHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX2JvYXJkW2ldLmNvbG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IGNvbG9yID09PSBXSElURSA/IHBpZWNlLnRvVXBwZXJDYXNlKCkgOiBwaWVjZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnICsgc3ltYm9sICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcyArPSAnIC4gJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoaSArIDEpICYgMHg4OCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJ3xcXG4nO1xuICAgICAgICAgICAgICAgIGkgKz0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzICs9ICcgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xcbic7XG4gICAgICAgIHMgKz0gJyAgICAgYSAgYiAgYyAgZCAgZSAgZiAgZyAgaCc7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBwZXJmdChkZXB0aCkge1xuICAgICAgICBjb25zdCBtb3ZlcyA9IHRoaXMuX21vdmVzKHsgbGVnYWw6IGZhbHNlIH0pO1xuICAgICAgICBsZXQgbm9kZXMgPSAwO1xuICAgICAgICBjb25zdCBjb2xvciA9IHRoaXMuX3R1cm47XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtb3Zlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZXNbaV0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc0tpbmdBdHRhY2tlZChjb2xvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggLSAxID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlcyArPSB0aGlzLnBlcmZ0KGRlcHRoIC0gMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlcysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VuZG9Nb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICAvLyBwcmV0dHkgPSBleHRlcm5hbCBtb3ZlIG9iamVjdFxuICAgIF9tYWtlUHJldHR5KHVnbHlNb3ZlKSB7XG4gICAgICAgIGNvbnN0IHsgY29sb3IsIHBpZWNlLCBmcm9tLCB0bywgZmxhZ3MsIGNhcHR1cmVkLCBwcm9tb3Rpb24gfSA9IHVnbHlNb3ZlO1xuICAgICAgICBsZXQgcHJldHR5RmxhZ3MgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBmbGFnIGluIEJJVFMpIHtcbiAgICAgICAgICAgIGlmIChCSVRTW2ZsYWddICYgZmxhZ3MpIHtcbiAgICAgICAgICAgICAgICBwcmV0dHlGbGFncyArPSBGTEFHU1tmbGFnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmcm9tQWxnZWJyYWljID0gYWxnZWJyYWljKGZyb20pO1xuICAgICAgICBjb25zdCB0b0FsZ2VicmFpYyA9IGFsZ2VicmFpYyh0byk7XG4gICAgICAgIGNvbnN0IG1vdmUgPSB7XG4gICAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAgIHBpZWNlLFxuICAgICAgICAgICAgZnJvbTogZnJvbUFsZ2VicmFpYyxcbiAgICAgICAgICAgIHRvOiB0b0FsZ2VicmFpYyxcbiAgICAgICAgICAgIHNhbjogdGhpcy5fbW92ZVRvU2FuKHVnbHlNb3ZlLCB0aGlzLl9tb3Zlcyh7IGxlZ2FsOiB0cnVlIH0pKSxcbiAgICAgICAgICAgIGZsYWdzOiBwcmV0dHlGbGFncyxcbiAgICAgICAgICAgIGxhbjogZnJvbUFsZ2VicmFpYyArIHRvQWxnZWJyYWljLFxuICAgICAgICAgICAgYmVmb3JlOiB0aGlzLmZlbigpLFxuICAgICAgICAgICAgYWZ0ZXI6ICcnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBnZW5lcmF0ZSB0aGUgRkVOIGZvciB0aGUgJ2FmdGVyJyBrZXlcbiAgICAgICAgdGhpcy5fbWFrZU1vdmUodWdseU1vdmUpO1xuICAgICAgICBtb3ZlLmFmdGVyID0gdGhpcy5mZW4oKTtcbiAgICAgICAgdGhpcy5fdW5kb01vdmUoKTtcbiAgICAgICAgaWYgKGNhcHR1cmVkKSB7XG4gICAgICAgICAgICBtb3ZlLmNhcHR1cmVkID0gY2FwdHVyZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21vdGlvbikge1xuICAgICAgICAgICAgbW92ZS5wcm9tb3Rpb24gPSBwcm9tb3Rpb247XG4gICAgICAgICAgICBtb3ZlLmxhbiArPSBwcm9tb3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmU7XG4gICAgfVxuICAgIHR1cm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90dXJuO1xuICAgIH1cbiAgICBib2FyZCgpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgICAgIGxldCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IE94ODguYTg7IGkgPD0gT3g4OC5oMTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9hcmRbaV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzcXVhcmU6IGFsZ2VicmFpYyhpKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5fYm9hcmRbaV0udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuX2JvYXJkW2ldLmNvbG9yLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpICsgMSkgJiAweDg4KSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2gocm93KTtcbiAgICAgICAgICAgICAgICByb3cgPSBbXTtcbiAgICAgICAgICAgICAgICBpICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgc3F1YXJlQ29sb3Ioc3F1YXJlKSB7XG4gICAgICAgIGlmIChzcXVhcmUgaW4gT3g4OCkge1xuICAgICAgICAgICAgY29uc3Qgc3EgPSBPeDg4W3NxdWFyZV07XG4gICAgICAgICAgICByZXR1cm4gKHJhbmsoc3EpICsgZmlsZShzcSkpICUgMiA9PT0gMCA/ICdsaWdodCcgOiAnZGFyayc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGhpc3RvcnkoeyB2ZXJib3NlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJldmVyc2VkSGlzdG9yeSA9IFtdO1xuICAgICAgICBjb25zdCBtb3ZlSGlzdG9yeSA9IFtdO1xuICAgICAgICB3aGlsZSAodGhpcy5faGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXZlcnNlZEhpc3RvcnkucHVzaCh0aGlzLl91bmRvTW92ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHJldmVyc2VkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBtb3ZlSGlzdG9yeS5wdXNoKHRoaXMuX21ha2VQcmV0dHkobW92ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW92ZUhpc3RvcnkucHVzaCh0aGlzLl9tb3ZlVG9TYW4obW92ZSwgdGhpcy5fbW92ZXMoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vdmVIaXN0b3J5O1xuICAgIH1cbiAgICBfcHJ1bmVDb21tZW50cygpIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRIaXN0b3J5ID0gW107XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb21tZW50cyA9IHt9O1xuICAgICAgICBjb25zdCBjb3B5Q29tbWVudCA9IChmZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChmZW4gaW4gdGhpcy5fY29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29tbWVudHNbZmVuXSA9IHRoaXMuX2NvbW1lbnRzW2Zlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldmVyc2VkSGlzdG9yeS5wdXNoKHRoaXMuX3VuZG9Nb3ZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvcHlDb21tZW50KHRoaXMuZmVuKCkpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbW92ZSA9IHJldmVyc2VkSGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgIGlmICghbW92ZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWFrZU1vdmUobW92ZSk7XG4gICAgICAgICAgICBjb3B5Q29tbWVudCh0aGlzLmZlbigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21tZW50cyA9IGN1cnJlbnRDb21tZW50cztcbiAgICB9XG4gICAgZ2V0Q29tbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1lbnRzW3RoaXMuZmVuKCldO1xuICAgIH1cbiAgICBzZXRDb21tZW50KGNvbW1lbnQpIHtcbiAgICAgICAgdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV0gPSBjb21tZW50LnJlcGxhY2UoJ3snLCAnWycpLnJlcGxhY2UoJ30nLCAnXScpO1xuICAgIH1cbiAgICBkZWxldGVDb21tZW50KCkge1xuICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbdGhpcy5mZW4oKV07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1t0aGlzLmZlbigpXTtcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQ7XG4gICAgfVxuICAgIGdldENvbW1lbnRzKCkge1xuICAgICAgICB0aGlzLl9wcnVuZUNvbW1lbnRzKCk7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9jb21tZW50cykubWFwKChmZW4pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGZlbjogZmVuLCBjb21tZW50OiB0aGlzLl9jb21tZW50c1tmZW5dIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGVDb21tZW50cygpIHtcbiAgICAgICAgdGhpcy5fcHJ1bmVDb21tZW50cygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY29tbWVudHMpLm1hcCgoZmVuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5fY29tbWVudHNbZmVuXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tZW50c1tmZW5dO1xuICAgICAgICAgICAgcmV0dXJuIHsgZmVuOiBmZW4sIGNvbW1lbnQ6IGNvbW1lbnQgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldENhc3RsaW5nUmlnaHRzKGNvbG9yLCByaWdodHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBzaWRlIG9mIFtLSU5HLCBRVUVFTl0pIHtcbiAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChyaWdodHNbc2lkZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdIHw9IFNJREVTW3NpZGVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FzdGxpbmdbY29sb3JdICY9IH5TSURFU1tzaWRlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2FzdGxpbmdSaWdodHMoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDYXN0bGluZ1JpZ2h0cyhjb2xvcik7XG4gICAgICAgIHJldHVybiAocmlnaHRzW0tJTkddID09PSB1bmRlZmluZWQgfHwgcmlnaHRzW0tJTkddID09PSByZXN1bHRbS0lOR10pICYmIChyaWdodHNbUVVFRU5dID09PSB1bmRlZmluZWQgfHwgcmlnaHRzW1FVRUVOXSA9PT0gcmVzdWx0W1FVRUVOXSk7XG4gICAgfVxuICAgIGdldENhc3RsaW5nUmlnaHRzKGNvbG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbS0lOR106ICh0aGlzLl9jYXN0bGluZ1tjb2xvcl0gJiBTSURFU1tLSU5HXSkgIT09IDAsXG4gICAgICAgICAgICBbUVVFRU5dOiAodGhpcy5fY2FzdGxpbmdbY29sb3JdICYgU0lERVNbUVVFRU5dKSAhPT0gMCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW92ZU51bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdmVOdW1iZXI7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chess.js/dist/esm/chess.js\n");

/***/ })

};
;